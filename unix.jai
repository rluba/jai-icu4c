//
// This file was auto-generated using the following command:
//
// jai generate.jai
//



U_DEBUG :: 0;

UCLN_NO_AUTO_CLEANUP :: 1;

U_DISABLE_RENAMING :: 0;

U_NO_DEFAULT_INCLUDE_UTF_HEADERS :: 0;

U_OVERRIDE_CXX_ALLOCATION :: 1;

U_ENABLE_TRACING :: 0;

UCONFIG_ENABLE_PLUGINS :: 0;

U_ENABLE_DYLOAD :: 1;

U_CHECK_DYLOAD :: 1;

U_DEFAULT_SHOW_DRAFT :: 1;

U_LIB_SUFFIX_C_NAME_STRING :: "";

UCONFIG_ONLY_COLLATION :: 0;

UCONFIG_NO_FILE_IO :: 0;

UCONFIG_NO_CONVERSION :: 0;

UCONFIG_ONLY_HTML_CONVERSION :: 0;

UCONFIG_NO_LEGACY_CONVERSION :: 0;

UCONFIG_NO_NORMALIZATION :: 0;

UCONFIG_USE_ML_PHRASE_BREAKING :: 0;

UCONFIG_NO_BREAK_ITERATION :: 0;

UCONFIG_NO_IDNA :: 0;

UCONFIG_USE_WINDOWS_LCID_MAPPING_API :: 1;

UCONFIG_NO_COLLATION :: 0;

UCONFIG_NO_FORMATTING :: 0;

UCONFIG_NO_TRANSLITERATION :: 0;

UCONFIG_NO_REGULAR_EXPRESSIONS :: 0;

UCONFIG_NO_SERVICE :: 0;

UCONFIG_HAVE_PARSEALLINPUT :: 1;

UCONFIG_NO_FILTERED_BREAK_ITERATION :: 0;

U_COPYRIGHT_STRING :: " Copyright (C) 2016 and later: Unicode, Inc. and others. License & terms of use: http://www.unicode.org/copyright.html ";

U_ICU_VERSION_MAJOR_NUM :: 73;

U_ICU_VERSION_MINOR_NUM :: 2;

U_ICU_VERSION_PATCHLEVEL_NUM :: 0;

U_ICU_VERSION_BUILDLEVEL_NUM :: 0;

U_DISABLE_VERSION_SUFFIX :: 0;

U_ICU_VERSION :: "73.2";

U_ICU_VERSION_SHORT :: "73";

U_ICU_DATA_VERSION :: "73.2";

UCOL_RUNTIME_VERSION :: 9;

UCOL_BUILDER_VERSION :: 9;

UCOL_TAILORINGS_VERSION :: 1;

U_PF_UNKNOWN :: 0;

U_PF_WINDOWS :: 1000;

U_PF_MINGW :: 1800;

U_PF_CYGWIN :: 1900;

U_PF_HPUX :: 2100;

U_PF_SOLARIS :: 2600;

U_PF_BSD :: 3000;

U_PF_AIX :: 3100;

U_PF_IRIX :: 3200;

U_PF_DARWIN :: 3500;

U_PF_IPHONE :: 3550;

U_PF_QNX :: 3700;

U_PF_LINUX :: 4000;

U_PF_BROWSER_NATIVE_CLIENT :: 4020;

U_PF_ANDROID :: 4050;

U_PF_FUCHSIA :: 4100;

U_PF_EMSCRIPTEN :: 5010;

U_PF_OS390 :: 9000;

U_PF_OS400 :: 9400;

U_PLATFORM :: U_PF_DARWIN;

U_PLATFORM_USES_ONLY_WIN32_API :: 0;

U_PLATFORM_HAS_WIN32_API :: 0;

U_PLATFORM_HAS_WINUWP_API :: 0;

U_PLATFORM_IMPLEMENTS_POSIX :: 1;

U_PLATFORM_IS_LINUX_BASED :: 0;

U_PLATFORM_IS_DARWIN_BASED :: 1;

U_HAVE_STDINT_H :: 1;

U_HAVE_INTTYPES_H :: U_HAVE_STDINT_H;

U_HAVE_PLACEMENT_NEW :: 1;

U_HAVE_DEBUG_LOCATION_NEW :: 0;

U_CPLUSPLUS_VERSION :: 0;

U_ASCII_FAMILY :: 0;

U_EBCDIC_FAMILY :: 1;

U_CHARSET_FAMILY :: U_ASCII_FAMILY;

U_CHARSET_IS_UTF8 :: 1;

U_HAVE_WCHAR_H :: 1;

U_SIZEOF_WCHAR_T :: 4;

U_HAVE_WCSCPY :: U_HAVE_WCHAR_H;

U_HAVE_CHAR16_T :: 1;

U_DEFINE_FALSE_AND_TRUE :: 0;

U_SIZEOF_UCHAR :: 2;

U_CHAR16_IS_TYPEDEF :: 0;

U_SENTINEL :: -1;

U_COPYRIGHT_STRING_LENGTH :: 128;

U_MAX_VERSION_LENGTH :: 4;

U_MAX_VERSION_STRING_LENGTH :: 20;

U8_LEAD3_T1_BITS :: "\x20\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30\x10\x30\x30";

U8_LEAD4_T1_BITS :: "\x00\x00\x00\x00\x00\x00\x00\x00\x1E\x0F\x0F\x0F\x00\x00\x00\x00";

U8_MAX_LENGTH :: 4;

U16_SURROGATE_OFFSET :: (0xd800<<10)+0xdc00-0x10000;

U16_MAX_LENGTH :: 2;

U_HIDE_OBSOLETE_UTF_OLD_H :: 0;

UTF_SIZE :: 16;

UTF8_ERROR_VALUE_1 :: 0x15;

UTF8_ERROR_VALUE_2 :: 0x9f;

UTF_ERROR_VALUE :: 0xffff;

UTF8_MAX_CHAR_LENGTH :: 4;

UTF_SURROGATE_OFFSET :: (0xd800<<10)+0xdc00-0x10000;

UTF16_MAX_CHAR_LENGTH :: 2;

UTF32_MAX_CHAR_LENGTH :: 1;

UTF_MAX_CHAR_LENGTH :: U16_MAX_LENGTH;

U_SHOW_CPLUSPLUS_API :: 0;

U_ICUDATA_TYPE_LETTER :: "l";

U_USE_USRDATA :: 0;

U_MILLIS_PER_SECOND :: 1000;

U_MILLIS_PER_MINUTE :: 60000;

U_MILLIS_PER_HOUR :: 3600000;

U_MILLIS_PER_DAY :: 86400000;

ULOC_CHINESE :: "zh";

ULOC_ENGLISH :: "en";

ULOC_FRENCH :: "fr";

ULOC_GERMAN :: "de";

ULOC_ITALIAN :: "it";

ULOC_JAPANESE :: "ja";

ULOC_KOREAN :: "ko";

ULOC_SIMPLIFIED_CHINESE :: "zh_CN";

ULOC_TRADITIONAL_CHINESE :: "zh_TW";

ULOC_CANADA :: "en_CA";

ULOC_CANADA_FRENCH :: "fr_CA";

ULOC_CHINA :: "zh_CN";

ULOC_PRC :: "zh_CN";

ULOC_FRANCE :: "fr_FR";

ULOC_GERMANY :: "de_DE";

ULOC_ITALY :: "it_IT";

ULOC_JAPAN :: "ja_JP";

ULOC_KOREA :: "ko_KR";

ULOC_TAIWAN :: "zh_TW";

ULOC_UK :: "en_GB";

ULOC_US :: "en_US";

ULOC_LANG_CAPACITY :: 12;

ULOC_COUNTRY_CAPACITY :: 4;

ULOC_FULLNAME_CAPACITY :: 157;

ULOC_SCRIPT_CAPACITY :: 6;

ULOC_KEYWORDS_CAPACITY :: 96;

ULOC_KEYWORD_AND_VALUES_CAPACITY :: 100;

ULOC_KEYWORD_SEPARATOR_UNICODE :: 0x40;

ULOC_KEYWORD_ASSIGN_UNICODE :: 0x3D;

ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE :: 0x3B;

UCAL_UNKNOWN_ZONE_ID :: "Etc/Unknown";

U_FILE_SEP_STRING :: "/";
U_FILE_ALT_SEP_STRING :: "/";
U_PATH_SEP_STRING :: ":";

UITER_NO_STATE :: cast(u32)0xffffffff;

/**
* The ICU boolean type, a signed-byte integer.
* ICU-specific for historical reasons: The C and C++ standards used to not define type bool.
* Also provides a fixed type definition, as opposed to
* type bool whose details (e.g., sizeof) may vary by compiler and between C and C++.
*
* @stable ICU 2.0
*/
UBool :: s8;

UChar :: u16;

OldUChar :: u16;

/**
* Define UChar32 as a type for single Unicode code points.
* UChar32 is a signed 32-bit integer (same as int32_t).
*
* The Unicode code point range is 0..0x10ffff.
* All other values (negative or >=0x110000) are illegal as Unicode code points.
* They may be used as sentinel values to indicate "done", "error"
* or similar non-code point conditions.
*
* Before ICU 2.4 (Jitterbug 2146), UChar32 was defined
* to be wchar_t if that is 32 bits wide (wchar_t may be signed or unsigned)
* or else to be uint32_t.
* That is, the definition of UChar32 was platform-dependent.
*
* @see U_SENTINEL
* @stable ICU 2.4
*/
UChar32 :: s32;

/** The binary form of a version on ICU APIs is an array of 4 uint8_t.
*  To compare two versions, use memcmp(v1,v2,sizeof(UVersionInfo)).
*  @stable ICU 2.4
*/
UVersionInfo :: [4] u8;

u_versionFromString :: (versionArray: *UVersionInfo, versionString: *u8) -> void #foreign libicutu "u_versionFromString_73";

u_versionFromUString :: (versionArray: *UVersionInfo, versionString: *UChar) -> void #foreign libicutu "u_versionFromUString_73";

u_versionToString :: (versionArray: *UVersionInfo, versionString: *u8) -> void #foreign libicutu "u_versionToString_73";

u_getVersion :: (versionArray: *UVersionInfo) -> void #foreign libicutu "u_getVersion_73";

utf8_nextCharSafeBody :: (s: *u8, pi: *s32, length: s32, c: UChar32, strict: UBool) -> UChar32 #foreign libicutu "utf8_nextCharSafeBody_73";

utf8_appendCharSafeBody :: (s: *u8, i: s32, length: s32, c: UChar32, pIsError: *UBool) -> s32 #foreign libicutu "utf8_appendCharSafeBody_73";

utf8_prevCharSafeBody :: (s: *u8, start: s32, pi: *s32, c: UChar32, strict: UBool) -> UChar32 #foreign libicutu "utf8_prevCharSafeBody_73";

utf8_back1SafeBody :: (s: *u8, start: s32, i: s32) -> s32 #foreign libicutu "utf8_back1SafeBody_73";

utf8_countTrailBytes: *u8 #elsewhere libicutu "utf8_countTrailBytes_73";

/**
* Date and Time data type.
* This is a primitive data type that holds the date and time
* as the number of milliseconds since 1970-jan-01, 00:00 UTC.
* UTC leap seconds are ignored.
* @stable ICU 2.0
*/
UDate :: float64;

/**
* Standard ICU4C error code type, a substitute for exceptions.
*
* Initialize the UErrorCode with U_ZERO_ERROR, and check for success or
* failure using U_SUCCESS() or U_FAILURE():
*
*     UErrorCode errorCode = U_ZERO_ERROR;
*     // call ICU API that needs an error code parameter.
*     if (U_FAILURE(errorCode)) {
*         // An error occurred. Handle it here.
*     }
*
* C++ code should use icu::ErrorCode, available in unicode/errorcode.h, or a
* suitable subclass.
*
* For more information, see:
* https://unicode-org.github.io/icu/userguide/dev/codingguidelines#details-about-icu-error-codes
*
* Note: By convention, ICU functions that take a reference (C++) or a pointer
* (C) to a UErrorCode first test:
*
*     if (U_FAILURE(errorCode)) { return immediately; }
*
* so that in a chain of such functions the first one that sets an error code
* causes the following ones to not perform any operations.
*
* @stable ICU 2.0
*/
UErrorCode :: enum s32 {
    USING_FALLBACK_WARNING           :: -128;

    ERROR_WARNING_START              :: -128;

    USING_DEFAULT_WARNING            :: -127;

    SAFECLONE_ALLOCATED_WARNING      :: -126;

    STATE_OLD_WARNING                :: -125;

    STRING_NOT_TERMINATED_WARNING    :: -124;

    SORT_KEY_TOO_SHORT_WARNING       :: -123;

    AMBIGUOUS_ALIAS_WARNING          :: -122;

    DIFFERENT_UCA_VERSION            :: -121;

    PLUGIN_CHANGED_LEVEL_WARNING     :: -120;

    ERROR_WARNING_LIMIT              :: -119;

    ZERO_ERROR                       :: 0;

    ILLEGAL_ARGUMENT_ERROR           :: 1;
    MISSING_RESOURCE_ERROR           :: 2;
    INVALID_FORMAT_ERROR             :: 3;
    FILE_ACCESS_ERROR                :: 4;
    INTERNAL_PROGRAM_ERROR           :: 5;
    MESSAGE_PARSE_ERROR              :: 6;
    MEMORY_ALLOCATION_ERROR          :: 7;
    INDEX_OUTOFBOUNDS_ERROR          :: 8;
    PARSE_ERROR                      :: 9;
    INVALID_CHAR_FOUND               :: 10;
    TRUNCATED_CHAR_FOUND             :: 11;
    ILLEGAL_CHAR_FOUND               :: 12;
    INVALID_TABLE_FORMAT             :: 13;
    INVALID_TABLE_FILE               :: 14;
    BUFFER_OVERFLOW_ERROR            :: 15;
    UNSUPPORTED_ERROR                :: 16;
    RESOURCE_TYPE_MISMATCH           :: 17;
    ILLEGAL_ESCAPE_SEQUENCE          :: 18;
    UNSUPPORTED_ESCAPE_SEQUENCE      :: 19;
    NO_SPACE_AVAILABLE               :: 20;
    CE_NOT_FOUND_ERROR               :: 21;
    PRIMARY_TOO_LONG_ERROR           :: 22;
    STATE_TOO_OLD_ERROR              :: 23;
    TOO_MANY_ALIASES_ERROR           :: 24;

    ENUM_OUT_OF_SYNC_ERROR           :: 25;
    INVARIANT_CONVERSION_ERROR       :: 26;
    INVALID_STATE_ERROR              :: 27;
    COLLATOR_VERSION_MISMATCH        :: 28;
    USELESS_COLLATOR_ERROR           :: 29;
    NO_WRITE_PERMISSION              :: 30;

    INPUT_TOO_LONG_ERROR             :: 31;

    STANDARD_ERROR_LIMIT             :: 32;

    BAD_VARIABLE_DEFINITION          :: 65536;
    PARSE_ERROR_START                :: 65536;
    MALFORMED_RULE                   :: 65537;
    MALFORMED_SET                    :: 65538;
    MALFORMED_SYMBOL_REFERENCE       :: 65539;
    MALFORMED_UNICODE_ESCAPE         :: 65540;
    MALFORMED_VARIABLE_DEFINITION    :: 65541;
    MALFORMED_VARIABLE_REFERENCE     :: 65542;
    MISMATCHED_SEGMENT_DELIMITERS    :: 65543;
    MISPLACED_ANCHOR_START           :: 65544;
    MISPLACED_CURSOR_OFFSET          :: 65545;
    MISPLACED_QUANTIFIER             :: 65546;
    MISSING_OPERATOR                 :: 65547;
    MISSING_SEGMENT_CLOSE            :: 65548;
    MULTIPLE_ANTE_CONTEXTS           :: 65549;
    MULTIPLE_CURSORS                 :: 65550;
    MULTIPLE_POST_CONTEXTS           :: 65551;
    TRAILING_BACKSLASH               :: 65552;
    UNDEFINED_SEGMENT_REFERENCE      :: 65553;
    UNDEFINED_VARIABLE               :: 65554;
    UNQUOTED_SPECIAL                 :: 65555;
    UNTERMINATED_QUOTE               :: 65556;
    RULE_MASK_ERROR                  :: 65557;
    MISPLACED_COMPOUND_FILTER        :: 65558;
    MULTIPLE_COMPOUND_FILTERS        :: 65559;
    INVALID_RBT_SYNTAX               :: 65560;
    INVALID_PROPERTY_PATTERN         :: 65561;
    MALFORMED_PRAGMA                 :: 65562;
    UNCLOSED_SEGMENT                 :: 65563;
    ILLEGAL_CHAR_IN_SEGMENT          :: 65564;
    VARIABLE_RANGE_EXHAUSTED         :: 65565;
    VARIABLE_RANGE_OVERLAP           :: 65566;
    ILLEGAL_CHARACTER                :: 65567;
    INTERNAL_TRANSLITERATOR_ERROR    :: 65568;
    INVALID_ID                       :: 65569;
    INVALID_FUNCTION                 :: 65570;

    PARSE_ERROR_LIMIT                :: 65571;

    UNEXPECTED_TOKEN                 :: 65792;
    FMT_PARSE_ERROR_START            :: 65792;
    MULTIPLE_DECIMAL_SEPARATORS      :: 65793;
    MULTIPLE_DECIMAL_SEPERATORS      :: 65793;
    MULTIPLE_EXPONENTIAL_SYMBOLS     :: 65794;
    MALFORMED_EXPONENTIAL_PATTERN    :: 65795;
    MULTIPLE_PERCENT_SYMBOLS         :: 65796;
    MULTIPLE_PERMILL_SYMBOLS         :: 65797;
    MULTIPLE_PAD_SPECIFIERS          :: 65798;
    PATTERN_SYNTAX_ERROR             :: 65799;
    ILLEGAL_PAD_POSITION             :: 65800;
    UNMATCHED_BRACES                 :: 65801;
    UNSUPPORTED_PROPERTY             :: 65802;
    UNSUPPORTED_ATTRIBUTE            :: 65803;
    ARGUMENT_TYPE_MISMATCH           :: 65804;
    DUPLICATE_KEYWORD                :: 65805;
    UNDEFINED_KEYWORD                :: 65806;
    DEFAULT_KEYWORD_MISSING          :: 65807;
    DECIMAL_NUMBER_SYNTAX_ERROR      :: 65808;
    FORMAT_INEXACT_ERROR             :: 65809;
    NUMBER_ARG_OUTOFBOUNDS_ERROR     :: 65810;
    NUMBER_SKELETON_SYNTAX_ERROR     :: 65811;

    FMT_PARSE_ERROR_LIMIT            :: 65812;

    BRK_INTERNAL_ERROR               :: 66048;
    BRK_ERROR_START                  :: 66048;
    BRK_HEX_DIGITS_EXPECTED          :: 66049;
    BRK_SEMICOLON_EXPECTED           :: 66050;
    BRK_RULE_SYNTAX                  :: 66051;
    BRK_UNCLOSED_SET                 :: 66052;
    BRK_ASSIGN_ERROR                 :: 66053;
    BRK_VARIABLE_REDFINITION         :: 66054;
    BRK_MISMATCHED_PAREN             :: 66055;
    BRK_NEW_LINE_IN_QUOTED_STRING    :: 66056;
    BRK_UNDEFINED_VARIABLE           :: 66057;
    BRK_INIT_ERROR                   :: 66058;
    BRK_RULE_EMPTY_SET               :: 66059;
    BRK_UNRECOGNIZED_OPTION          :: 66060;
    BRK_MALFORMED_RULE_TAG           :: 66061;

    BRK_ERROR_LIMIT                  :: 66062;

    REGEX_INTERNAL_ERROR             :: 66304;
    REGEX_ERROR_START                :: 66304;
    REGEX_RULE_SYNTAX                :: 66305;
    REGEX_INVALID_STATE              :: 66306;
    REGEX_BAD_ESCAPE_SEQUENCE        :: 66307;
    REGEX_PROPERTY_SYNTAX            :: 66308;
    REGEX_UNIMPLEMENTED              :: 66309;
    REGEX_MISMATCHED_PAREN           :: 66310;
    REGEX_NUMBER_TOO_BIG             :: 66311;
    REGEX_BAD_INTERVAL               :: 66312;
    REGEX_MAX_LT_MIN                 :: 66313;
    REGEX_INVALID_BACK_REF           :: 66314;
    REGEX_INVALID_FLAG               :: 66315;
    REGEX_LOOK_BEHIND_LIMIT          :: 66316;
    REGEX_SET_CONTAINS_STRING        :: 66317;

    REGEX_OCTAL_TOO_BIG              :: 66318;

    REGEX_MISSING_CLOSE_BRACKET      :: 66319;
    REGEX_INVALID_RANGE              :: 66320;
    REGEX_STACK_OVERFLOW             :: 66321;
    REGEX_TIME_OUT                   :: 66322;
    REGEX_STOPPED_BY_CALLER          :: 66323;
    REGEX_PATTERN_TOO_BIG            :: 66324;
    REGEX_INVALID_CAPTURE_GROUP_NAME :: 66325;

    REGEX_ERROR_LIMIT                :: 66326;

    IDNA_PROHIBITED_ERROR            :: 66560;
    IDNA_ERROR_START                 :: 66560;
    IDNA_UNASSIGNED_ERROR            :: 66561;
    IDNA_CHECK_BIDI_ERROR            :: 66562;
    IDNA_STD3_ASCII_RULES_ERROR      :: 66563;
    IDNA_ACE_PREFIX_ERROR            :: 66564;
    IDNA_VERIFICATION_ERROR          :: 66565;
    IDNA_LABEL_TOO_LONG_ERROR        :: 66566;
    IDNA_ZERO_LENGTH_LABEL_ERROR     :: 66567;
    IDNA_DOMAIN_NAME_TOO_LONG_ERROR  :: 66568;

    IDNA_ERROR_LIMIT                 :: 66569;

    STRINGPREP_PROHIBITED_ERROR      :: 66560;
    STRINGPREP_UNASSIGNED_ERROR      :: 66561;
    STRINGPREP_CHECK_BIDI_ERROR      :: 66562;

    PLUGIN_ERROR_START               :: 66816;
    PLUGIN_TOO_HIGH                  :: 66816;
    PLUGIN_DIDNT_SET_LEVEL           :: 66817;

    PLUGIN_ERROR_LIMIT               :: 66818;

    ERROR_LIMIT                      :: 66818;

    U_USING_FALLBACK_WARNING           :: USING_FALLBACK_WARNING;

    U_ERROR_WARNING_START              :: ERROR_WARNING_START;

    U_USING_DEFAULT_WARNING            :: USING_DEFAULT_WARNING;

    U_SAFECLONE_ALLOCATED_WARNING      :: SAFECLONE_ALLOCATED_WARNING;

    U_STATE_OLD_WARNING                :: STATE_OLD_WARNING;

    U_STRING_NOT_TERMINATED_WARNING    :: STRING_NOT_TERMINATED_WARNING;

    U_SORT_KEY_TOO_SHORT_WARNING       :: SORT_KEY_TOO_SHORT_WARNING;

    U_AMBIGUOUS_ALIAS_WARNING          :: AMBIGUOUS_ALIAS_WARNING;

    U_DIFFERENT_UCA_VERSION            :: DIFFERENT_UCA_VERSION;

    U_PLUGIN_CHANGED_LEVEL_WARNING     :: PLUGIN_CHANGED_LEVEL_WARNING;

    U_ERROR_WARNING_LIMIT              :: ERROR_WARNING_LIMIT;

    U_ZERO_ERROR                       :: ZERO_ERROR;

    U_ILLEGAL_ARGUMENT_ERROR           :: ILLEGAL_ARGUMENT_ERROR;
    U_MISSING_RESOURCE_ERROR           :: MISSING_RESOURCE_ERROR;
    U_INVALID_FORMAT_ERROR             :: INVALID_FORMAT_ERROR;
    U_FILE_ACCESS_ERROR                :: FILE_ACCESS_ERROR;
    U_INTERNAL_PROGRAM_ERROR           :: INTERNAL_PROGRAM_ERROR;
    U_MESSAGE_PARSE_ERROR              :: MESSAGE_PARSE_ERROR;
    U_MEMORY_ALLOCATION_ERROR          :: MEMORY_ALLOCATION_ERROR;
    U_INDEX_OUTOFBOUNDS_ERROR          :: INDEX_OUTOFBOUNDS_ERROR;
    U_PARSE_ERROR                      :: PARSE_ERROR;
    U_INVALID_CHAR_FOUND               :: INVALID_CHAR_FOUND;
    U_TRUNCATED_CHAR_FOUND             :: TRUNCATED_CHAR_FOUND;
    U_ILLEGAL_CHAR_FOUND               :: ILLEGAL_CHAR_FOUND;
    U_INVALID_TABLE_FORMAT             :: INVALID_TABLE_FORMAT;
    U_INVALID_TABLE_FILE               :: INVALID_TABLE_FILE;
    U_BUFFER_OVERFLOW_ERROR            :: BUFFER_OVERFLOW_ERROR;
    U_UNSUPPORTED_ERROR                :: UNSUPPORTED_ERROR;
    U_RESOURCE_TYPE_MISMATCH           :: RESOURCE_TYPE_MISMATCH;
    U_ILLEGAL_ESCAPE_SEQUENCE          :: ILLEGAL_ESCAPE_SEQUENCE;
    U_UNSUPPORTED_ESCAPE_SEQUENCE      :: UNSUPPORTED_ESCAPE_SEQUENCE;
    U_NO_SPACE_AVAILABLE               :: NO_SPACE_AVAILABLE;
    U_CE_NOT_FOUND_ERROR               :: CE_NOT_FOUND_ERROR;
    U_PRIMARY_TOO_LONG_ERROR           :: PRIMARY_TOO_LONG_ERROR;
    U_STATE_TOO_OLD_ERROR              :: STATE_TOO_OLD_ERROR;
    U_TOO_MANY_ALIASES_ERROR           :: TOO_MANY_ALIASES_ERROR;

    U_ENUM_OUT_OF_SYNC_ERROR           :: ENUM_OUT_OF_SYNC_ERROR;
    U_INVARIANT_CONVERSION_ERROR       :: INVARIANT_CONVERSION_ERROR;
    U_INVALID_STATE_ERROR              :: INVALID_STATE_ERROR;
    U_COLLATOR_VERSION_MISMATCH        :: COLLATOR_VERSION_MISMATCH;
    U_USELESS_COLLATOR_ERROR           :: USELESS_COLLATOR_ERROR;
    U_NO_WRITE_PERMISSION              :: NO_WRITE_PERMISSION;

    U_INPUT_TOO_LONG_ERROR             :: INPUT_TOO_LONG_ERROR;

    U_STANDARD_ERROR_LIMIT             :: STANDARD_ERROR_LIMIT;

    U_BAD_VARIABLE_DEFINITION          :: BAD_VARIABLE_DEFINITION;
    U_PARSE_ERROR_START                :: PARSE_ERROR_START;
    U_MALFORMED_RULE                   :: MALFORMED_RULE;
    U_MALFORMED_SET                    :: MALFORMED_SET;
    U_MALFORMED_SYMBOL_REFERENCE       :: MALFORMED_SYMBOL_REFERENCE;
    U_MALFORMED_UNICODE_ESCAPE         :: MALFORMED_UNICODE_ESCAPE;
    U_MALFORMED_VARIABLE_DEFINITION    :: MALFORMED_VARIABLE_DEFINITION;
    U_MALFORMED_VARIABLE_REFERENCE     :: MALFORMED_VARIABLE_REFERENCE;
    U_MISMATCHED_SEGMENT_DELIMITERS    :: MISMATCHED_SEGMENT_DELIMITERS;
    U_MISPLACED_ANCHOR_START           :: MISPLACED_ANCHOR_START;
    U_MISPLACED_CURSOR_OFFSET          :: MISPLACED_CURSOR_OFFSET;
    U_MISPLACED_QUANTIFIER             :: MISPLACED_QUANTIFIER;
    U_MISSING_OPERATOR                 :: MISSING_OPERATOR;
    U_MISSING_SEGMENT_CLOSE            :: MISSING_SEGMENT_CLOSE;
    U_MULTIPLE_ANTE_CONTEXTS           :: MULTIPLE_ANTE_CONTEXTS;
    U_MULTIPLE_CURSORS                 :: MULTIPLE_CURSORS;
    U_MULTIPLE_POST_CONTEXTS           :: MULTIPLE_POST_CONTEXTS;
    U_TRAILING_BACKSLASH               :: TRAILING_BACKSLASH;
    U_UNDEFINED_SEGMENT_REFERENCE      :: UNDEFINED_SEGMENT_REFERENCE;
    U_UNDEFINED_VARIABLE               :: UNDEFINED_VARIABLE;
    U_UNQUOTED_SPECIAL                 :: UNQUOTED_SPECIAL;
    U_UNTERMINATED_QUOTE               :: UNTERMINATED_QUOTE;
    U_RULE_MASK_ERROR                  :: RULE_MASK_ERROR;
    U_MISPLACED_COMPOUND_FILTER        :: MISPLACED_COMPOUND_FILTER;
    U_MULTIPLE_COMPOUND_FILTERS        :: MULTIPLE_COMPOUND_FILTERS;
    U_INVALID_RBT_SYNTAX               :: INVALID_RBT_SYNTAX;
    U_INVALID_PROPERTY_PATTERN         :: INVALID_PROPERTY_PATTERN;
    U_MALFORMED_PRAGMA                 :: MALFORMED_PRAGMA;
    U_UNCLOSED_SEGMENT                 :: UNCLOSED_SEGMENT;
    U_ILLEGAL_CHAR_IN_SEGMENT          :: ILLEGAL_CHAR_IN_SEGMENT;
    U_VARIABLE_RANGE_EXHAUSTED         :: VARIABLE_RANGE_EXHAUSTED;
    U_VARIABLE_RANGE_OVERLAP           :: VARIABLE_RANGE_OVERLAP;
    U_ILLEGAL_CHARACTER                :: ILLEGAL_CHARACTER;
    U_INTERNAL_TRANSLITERATOR_ERROR    :: INTERNAL_TRANSLITERATOR_ERROR;
    U_INVALID_ID                       :: INVALID_ID;
    U_INVALID_FUNCTION                 :: INVALID_FUNCTION;

    U_PARSE_ERROR_LIMIT                :: PARSE_ERROR_LIMIT;

    U_UNEXPECTED_TOKEN                 :: UNEXPECTED_TOKEN;
    U_FMT_PARSE_ERROR_START            :: FMT_PARSE_ERROR_START;
    U_MULTIPLE_DECIMAL_SEPARATORS      :: MULTIPLE_DECIMAL_SEPARATORS;
    U_MULTIPLE_DECIMAL_SEPERATORS      :: MULTIPLE_DECIMAL_SEPERATORS;
    U_MULTIPLE_EXPONENTIAL_SYMBOLS     :: MULTIPLE_EXPONENTIAL_SYMBOLS;
    U_MALFORMED_EXPONENTIAL_PATTERN    :: MALFORMED_EXPONENTIAL_PATTERN;
    U_MULTIPLE_PERCENT_SYMBOLS         :: MULTIPLE_PERCENT_SYMBOLS;
    U_MULTIPLE_PERMILL_SYMBOLS         :: MULTIPLE_PERMILL_SYMBOLS;
    U_MULTIPLE_PAD_SPECIFIERS          :: MULTIPLE_PAD_SPECIFIERS;
    U_PATTERN_SYNTAX_ERROR             :: PATTERN_SYNTAX_ERROR;
    U_ILLEGAL_PAD_POSITION             :: ILLEGAL_PAD_POSITION;
    U_UNMATCHED_BRACES                 :: UNMATCHED_BRACES;
    U_UNSUPPORTED_PROPERTY             :: UNSUPPORTED_PROPERTY;
    U_UNSUPPORTED_ATTRIBUTE            :: UNSUPPORTED_ATTRIBUTE;
    U_ARGUMENT_TYPE_MISMATCH           :: ARGUMENT_TYPE_MISMATCH;
    U_DUPLICATE_KEYWORD                :: DUPLICATE_KEYWORD;
    U_UNDEFINED_KEYWORD                :: UNDEFINED_KEYWORD;
    U_DEFAULT_KEYWORD_MISSING          :: DEFAULT_KEYWORD_MISSING;
    U_DECIMAL_NUMBER_SYNTAX_ERROR      :: DECIMAL_NUMBER_SYNTAX_ERROR;
    U_FORMAT_INEXACT_ERROR             :: FORMAT_INEXACT_ERROR;
    U_NUMBER_ARG_OUTOFBOUNDS_ERROR     :: NUMBER_ARG_OUTOFBOUNDS_ERROR;
    U_NUMBER_SKELETON_SYNTAX_ERROR     :: NUMBER_SKELETON_SYNTAX_ERROR;

    U_FMT_PARSE_ERROR_LIMIT            :: FMT_PARSE_ERROR_LIMIT;

    U_BRK_INTERNAL_ERROR               :: BRK_INTERNAL_ERROR;
    U_BRK_ERROR_START                  :: BRK_ERROR_START;
    U_BRK_HEX_DIGITS_EXPECTED          :: BRK_HEX_DIGITS_EXPECTED;
    U_BRK_SEMICOLON_EXPECTED           :: BRK_SEMICOLON_EXPECTED;
    U_BRK_RULE_SYNTAX                  :: BRK_RULE_SYNTAX;
    U_BRK_UNCLOSED_SET                 :: BRK_UNCLOSED_SET;
    U_BRK_ASSIGN_ERROR                 :: BRK_ASSIGN_ERROR;
    U_BRK_VARIABLE_REDFINITION         :: BRK_VARIABLE_REDFINITION;
    U_BRK_MISMATCHED_PAREN             :: BRK_MISMATCHED_PAREN;
    U_BRK_NEW_LINE_IN_QUOTED_STRING    :: BRK_NEW_LINE_IN_QUOTED_STRING;
    U_BRK_UNDEFINED_VARIABLE           :: BRK_UNDEFINED_VARIABLE;
    U_BRK_INIT_ERROR                   :: BRK_INIT_ERROR;
    U_BRK_RULE_EMPTY_SET               :: BRK_RULE_EMPTY_SET;
    U_BRK_UNRECOGNIZED_OPTION          :: BRK_UNRECOGNIZED_OPTION;
    U_BRK_MALFORMED_RULE_TAG           :: BRK_MALFORMED_RULE_TAG;

    U_BRK_ERROR_LIMIT                  :: BRK_ERROR_LIMIT;

    U_REGEX_INTERNAL_ERROR             :: REGEX_INTERNAL_ERROR;
    U_REGEX_ERROR_START                :: REGEX_ERROR_START;
    U_REGEX_RULE_SYNTAX                :: REGEX_RULE_SYNTAX;
    U_REGEX_INVALID_STATE              :: REGEX_INVALID_STATE;
    U_REGEX_BAD_ESCAPE_SEQUENCE        :: REGEX_BAD_ESCAPE_SEQUENCE;
    U_REGEX_PROPERTY_SYNTAX            :: REGEX_PROPERTY_SYNTAX;
    U_REGEX_UNIMPLEMENTED              :: REGEX_UNIMPLEMENTED;
    U_REGEX_MISMATCHED_PAREN           :: REGEX_MISMATCHED_PAREN;
    U_REGEX_NUMBER_TOO_BIG             :: REGEX_NUMBER_TOO_BIG;
    U_REGEX_BAD_INTERVAL               :: REGEX_BAD_INTERVAL;
    U_REGEX_MAX_LT_MIN                 :: REGEX_MAX_LT_MIN;
    U_REGEX_INVALID_BACK_REF           :: REGEX_INVALID_BACK_REF;
    U_REGEX_INVALID_FLAG               :: REGEX_INVALID_FLAG;
    U_REGEX_LOOK_BEHIND_LIMIT          :: REGEX_LOOK_BEHIND_LIMIT;
    U_REGEX_SET_CONTAINS_STRING        :: REGEX_SET_CONTAINS_STRING;

    U_REGEX_OCTAL_TOO_BIG              :: REGEX_OCTAL_TOO_BIG;

    U_REGEX_MISSING_CLOSE_BRACKET      :: REGEX_MISSING_CLOSE_BRACKET;
    U_REGEX_INVALID_RANGE              :: REGEX_INVALID_RANGE;
    U_REGEX_STACK_OVERFLOW             :: REGEX_STACK_OVERFLOW;
    U_REGEX_TIME_OUT                   :: REGEX_TIME_OUT;
    U_REGEX_STOPPED_BY_CALLER          :: REGEX_STOPPED_BY_CALLER;
    U_REGEX_PATTERN_TOO_BIG            :: REGEX_PATTERN_TOO_BIG;
    U_REGEX_INVALID_CAPTURE_GROUP_NAME :: REGEX_INVALID_CAPTURE_GROUP_NAME;

    U_REGEX_ERROR_LIMIT                :: REGEX_ERROR_LIMIT;

    U_IDNA_PROHIBITED_ERROR            :: IDNA_PROHIBITED_ERROR;
    U_IDNA_ERROR_START                 :: IDNA_ERROR_START;
    U_IDNA_UNASSIGNED_ERROR            :: IDNA_UNASSIGNED_ERROR;
    U_IDNA_CHECK_BIDI_ERROR            :: IDNA_CHECK_BIDI_ERROR;
    U_IDNA_STD3_ASCII_RULES_ERROR      :: IDNA_STD3_ASCII_RULES_ERROR;
    U_IDNA_ACE_PREFIX_ERROR            :: IDNA_ACE_PREFIX_ERROR;
    U_IDNA_VERIFICATION_ERROR          :: IDNA_VERIFICATION_ERROR;
    U_IDNA_LABEL_TOO_LONG_ERROR        :: IDNA_LABEL_TOO_LONG_ERROR;
    U_IDNA_ZERO_LENGTH_LABEL_ERROR     :: IDNA_ZERO_LENGTH_LABEL_ERROR;
    U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR  :: IDNA_DOMAIN_NAME_TOO_LONG_ERROR;

    U_IDNA_ERROR_LIMIT                 :: IDNA_ERROR_LIMIT;

    U_STRINGPREP_PROHIBITED_ERROR      :: STRINGPREP_PROHIBITED_ERROR;
    U_STRINGPREP_UNASSIGNED_ERROR      :: STRINGPREP_UNASSIGNED_ERROR;
    U_STRINGPREP_CHECK_BIDI_ERROR      :: STRINGPREP_CHECK_BIDI_ERROR;

    U_PLUGIN_ERROR_START               :: PLUGIN_ERROR_START;
    U_PLUGIN_TOO_HIGH                  :: PLUGIN_TOO_HIGH;
    U_PLUGIN_DIDNT_SET_LEVEL           :: PLUGIN_DIDNT_SET_LEVEL;

    U_PLUGIN_ERROR_LIMIT               :: PLUGIN_ERROR_LIMIT;

    U_ERROR_LIMIT                      :: ERROR_LIMIT;
}

u_errorName :: (code: UErrorCode) -> *u8 #foreign libicutu "u_errorName_73";

/**
* An enumeration object.
* For usage in C programs.
* @stable ICU 2.2
*/
UEnumeration :: struct {}

uenum_close :: (en: *UEnumeration) -> void #foreign libicutu "uenum_close_73";

uenum_count :: (en: *UEnumeration, status: *UErrorCode) -> s32 #foreign libicutu "uenum_count_73";

uenum_unext :: (en: *UEnumeration, resultLength: *s32, status: *UErrorCode) -> *UChar #foreign libicutu "uenum_unext_73";

uenum_next :: (en: *UEnumeration, resultLength: *s32, status: *UErrorCode) -> *u8 #foreign libicutu "uenum_next_73";

uenum_reset :: (en: *UEnumeration, status: *UErrorCode) -> void #foreign libicutu "uenum_reset_73";

uenum_openUCharStringsEnumeration :: (strings: **UChar, count: s32, ec: *UErrorCode) -> *UEnumeration #foreign libicutu "uenum_openUCharStringsEnumeration_73";

uenum_openCharStringsEnumeration :: (strings: **u8, count: s32, ec: *UErrorCode) -> *UEnumeration #foreign libicutu "uenum_openCharStringsEnumeration_73";

/**
* Constants for *_getLocale()
* Allow user to select whether she wants information on
* requested, valid or actual locale.
* For example, a collator for "en_US_CALIFORNIA" was
* requested. In the current state of ICU (2.0),
* the requested locale is "en_US_CALIFORNIA",
* the valid locale is "en_US" (most specific locale supported by ICU)
* and the actual locale is "root" (the collation data comes unmodified
* from the UCA)
* The locale is considered supported by ICU if there is a core ICU bundle
* for that locale (although it may be empty).
* @stable ICU 2.1
*/
ULocDataLocaleType :: enum u32 {
    ACTUAL_LOCALE          :: 0;

    VALID_LOCALE           :: 1;

    REQUESTED_LOCALE       :: 2;

    DATA_LOCALE_TYPE_LIMIT :: 3;

    ULOC_ACTUAL_LOCALE          :: ACTUAL_LOCALE;

    ULOC_VALID_LOCALE           :: VALID_LOCALE;

    ULOC_REQUESTED_LOCALE       :: REQUESTED_LOCALE;

    ULOC_DATA_LOCALE_TYPE_LIMIT :: DATA_LOCALE_TYPE_LIMIT;
}

uloc_getDefault :: () -> *u8 #foreign libicutu "uloc_getDefault_73";

uloc_setDefault :: (localeID: *u8, status: *UErrorCode) -> void #foreign libicutu "uloc_setDefault_73";

uloc_getLanguage :: (localeID: *u8, language: *u8, languageCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getLanguage_73";

uloc_getScript :: (localeID: *u8, script: *u8, scriptCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getScript_73";

uloc_getCountry :: (localeID: *u8, country: *u8, countryCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getCountry_73";

uloc_getVariant :: (localeID: *u8, variant: *u8, variantCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getVariant_73";

uloc_getName :: (localeID: *u8, name: *u8, nameCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getName_73";

uloc_canonicalize :: (localeID: *u8, name: *u8, nameCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_canonicalize_73";

uloc_getISO3Language :: (localeID: *u8) -> *u8 #foreign libicutu "uloc_getISO3Language_73";

uloc_getISO3Country :: (localeID: *u8) -> *u8 #foreign libicutu "uloc_getISO3Country_73";

uloc_getLCID :: (localeID: *u8) -> u32 #foreign libicutu "uloc_getLCID_73";

uloc_getDisplayLanguage :: (locale: *u8, displayLocale: *u8, language: *UChar, languageCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayLanguage_73";

uloc_getDisplayScript :: (locale: *u8, displayLocale: *u8, script: *UChar, scriptCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayScript_73";

uloc_getDisplayCountry :: (locale: *u8, displayLocale: *u8, country: *UChar, countryCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayCountry_73";

uloc_getDisplayVariant :: (locale: *u8, displayLocale: *u8, variant: *UChar, variantCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayVariant_73";

uloc_getDisplayKeyword :: (keyword: *u8, displayLocale: *u8, dest: *UChar, destCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayKeyword_73";

uloc_getDisplayKeywordValue :: (locale: *u8, keyword: *u8, displayLocale: *u8, dest: *UChar, destCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayKeywordValue_73";

uloc_getDisplayName :: (localeID: *u8, inLocaleID: *u8, result: *UChar, maxResultSize: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayName_73";

uloc_getAvailable :: (n: s32) -> *u8 #foreign libicutu "uloc_getAvailable_73";

uloc_countAvailable :: () -> s32 #foreign libicutu "uloc_countAvailable_73";

/**
* Types for uloc_getAvailableByType and uloc_countAvailableByType.
*
* @stable ICU 65
*/
ULocAvailableType :: enum u32 {
    DEFAULT             :: 0;

    ONLY_LEGACY_ALIASES :: 1;

    WITH_LEGACY_ALIASES :: 2;

    COUNT               :: 3;

    ULOC_AVAILABLE_DEFAULT             :: DEFAULT;

    ULOC_AVAILABLE_ONLY_LEGACY_ALIASES :: ONLY_LEGACY_ALIASES;

    ULOC_AVAILABLE_WITH_LEGACY_ALIASES :: WITH_LEGACY_ALIASES;

    ULOC_AVAILABLE_COUNT               :: COUNT;
}

uloc_openAvailableByType :: (type: ULocAvailableType, status: *UErrorCode) -> *UEnumeration #foreign libicutu "uloc_openAvailableByType_73";

uloc_getISOLanguages :: () -> **u8 #foreign libicutu "uloc_getISOLanguages_73";

uloc_getISOCountries :: () -> **u8 #foreign libicutu "uloc_getISOCountries_73";

uloc_getParent :: (localeID: *u8, parent: *u8, parentCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getParent_73";

uloc_getBaseName :: (localeID: *u8, name: *u8, nameCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getBaseName_73";

uloc_openKeywords :: (localeID: *u8, status: *UErrorCode) -> *UEnumeration #foreign libicutu "uloc_openKeywords_73";

uloc_getKeywordValue :: (localeID: *u8, keywordName: *u8, buffer: *u8, bufferCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getKeywordValue_73";

uloc_setKeywordValue :: (keywordName: *u8, keywordValue: *u8, buffer: *u8, bufferCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_setKeywordValue_73";

uloc_isRightToLeft :: (locale: *u8) -> UBool #foreign libicutu "uloc_isRightToLeft_73";

/**
* enums for the  return value for the character and line orientation
* functions.
* @stable ICU 4.0
*/
ULayoutType :: enum u32 {
    LTR     :: 0;
    RTL     :: 1;
    TTB     :: 2;
    BTT     :: 3;
    UNKNOWN :: 4;

    ULOC_LAYOUT_LTR     :: LTR;
    ULOC_LAYOUT_RTL     :: RTL;
    ULOC_LAYOUT_TTB     :: TTB;
    ULOC_LAYOUT_BTT     :: BTT;
    ULOC_LAYOUT_UNKNOWN :: UNKNOWN;
}

uloc_getCharacterOrientation :: (localeId: *u8, status: *UErrorCode) -> ULayoutType #foreign libicutu "uloc_getCharacterOrientation_73";

uloc_getLineOrientation :: (localeId: *u8, status: *UErrorCode) -> ULayoutType #foreign libicutu "uloc_getLineOrientation_73";

/**
* Output values which uloc_acceptLanguage() writes to the 'outResult' parameter.
*
* @see uloc_acceptLanguageFromHTTP
* @see uloc_acceptLanguage
* @stable ICU 3.2
*/
UAcceptResult :: enum u32 {
    FAILED   :: 0;

    VALID    :: 1;

    FALLBACK :: 2;

    ULOC_ACCEPT_FAILED   :: FAILED;

    ULOC_ACCEPT_VALID    :: VALID;

    ULOC_ACCEPT_FALLBACK :: FALLBACK;
}

uloc_acceptLanguageFromHTTP :: (result: *u8, resultAvailable: s32, outResult: *UAcceptResult, httpAcceptLanguage: *u8, availableLocales: *UEnumeration, status: *UErrorCode) -> s32 #foreign libicutu "uloc_acceptLanguageFromHTTP_73";

uloc_acceptLanguage :: (result: *u8, resultAvailable: s32, outResult: *UAcceptResult, acceptList: **u8, acceptListCount: s32, availableLocales: *UEnumeration, status: *UErrorCode) -> s32 #foreign libicutu "uloc_acceptLanguage_73";

uloc_getLocaleForLCID :: (hostID: u32, locale: *u8, localeCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getLocaleForLCID_73";

uloc_addLikelySubtags :: (localeID: *u8, maximizedLocaleID: *u8, maximizedLocaleIDCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_addLikelySubtags_73";

uloc_minimizeSubtags :: (localeID: *u8, minimizedLocaleID: *u8, minimizedLocaleIDCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_minimizeSubtags_73";

uloc_forLanguageTag :: (langtag: *u8, localeID: *u8, localeIDCapacity: s32, parsedLength: *s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_forLanguageTag_73";

uloc_toLanguageTag :: (localeID: *u8, langtag: *u8, langtagCapacity: s32, strict: UBool, err: *UErrorCode) -> s32 #foreign libicutu "uloc_toLanguageTag_73";

uloc_toUnicodeLocaleKey :: (keyword: *u8) -> *u8 #foreign libicutu "uloc_toUnicodeLocaleKey_73";

uloc_toUnicodeLocaleType :: (keyword: *u8, value: *u8) -> *u8 #foreign libicutu "uloc_toUnicodeLocaleType_73";

uloc_toLegacyKey :: (keyword: *u8) -> *u8 #foreign libicutu "uloc_toLegacyKey_73";

uloc_toLegacyType :: (keyword: *u8, value: *u8) -> *u8 #foreign libicutu "uloc_toLegacyType_73";

/** A calendar.
*  For usage in C programs.
* @stable ICU 2.0
*/
UCalendar :: *void;

/** Possible types of UCalendars
* @stable ICU 2.0
*/
UCalendarType :: enum u32 {
    TRADITIONAL :: 0;

    DEFAULT     :: 0;

    GREGORIAN   :: 1;

    UCAL_TRADITIONAL :: TRADITIONAL;

    UCAL_DEFAULT     :: DEFAULT;

    UCAL_GREGORIAN   :: GREGORIAN;
}

/** Possible fields in a UCalendar
* @stable ICU 2.0
*/
UCalendarDateFields :: enum u32 {
    ERA                  :: 0;

    YEAR                 :: 1;

    MONTH                :: 2;

    WEEK_OF_YEAR         :: 3;

    WEEK_OF_MONTH        :: 4;

    DATE                 :: 5;

    DAY_OF_YEAR          :: 6;

    DAY_OF_WEEK          :: 7;

    DAY_OF_WEEK_IN_MONTH :: 8;

    AM_PM                :: 9;

    HOUR                 :: 10;

    HOUR_OF_DAY          :: 11;

    MINUTE               :: 12;

    SECOND               :: 13;

    MILLISECOND          :: 14;

    ZONE_OFFSET          :: 15;

    DST_OFFSET           :: 16;

    YEAR_WOY             :: 17;

    DOW_LOCAL            :: 18;

    EXTENDED_YEAR        :: 19;

    JULIAN_DAY           :: 20;

    MILLISECONDS_IN_DAY  :: 21;

    IS_LEAP_MONTH        :: 22;

    ORDINAL_MONTH        :: 23;

    FIELD_COUNT          :: 24;

    DAY_OF_MONTH         :: 5;

    UCAL_ERA                  :: ERA;

    UCAL_YEAR                 :: YEAR;

    UCAL_MONTH                :: MONTH;

    UCAL_WEEK_OF_YEAR         :: WEEK_OF_YEAR;

    UCAL_WEEK_OF_MONTH        :: WEEK_OF_MONTH;

    UCAL_DATE                 :: DATE;

    UCAL_DAY_OF_YEAR          :: DAY_OF_YEAR;

    UCAL_DAY_OF_WEEK          :: DAY_OF_WEEK;

    UCAL_DAY_OF_WEEK_IN_MONTH :: DAY_OF_WEEK_IN_MONTH;

    UCAL_AM_PM                :: AM_PM;

    UCAL_HOUR                 :: HOUR;

    UCAL_HOUR_OF_DAY          :: HOUR_OF_DAY;

    UCAL_MINUTE               :: MINUTE;

    UCAL_SECOND               :: SECOND;

    UCAL_MILLISECOND          :: MILLISECOND;

    UCAL_ZONE_OFFSET          :: ZONE_OFFSET;

    UCAL_DST_OFFSET           :: DST_OFFSET;

    UCAL_YEAR_WOY             :: YEAR_WOY;

    UCAL_DOW_LOCAL            :: DOW_LOCAL;

    UCAL_EXTENDED_YEAR        :: EXTENDED_YEAR;

    UCAL_JULIAN_DAY           :: JULIAN_DAY;

    UCAL_MILLISECONDS_IN_DAY  :: MILLISECONDS_IN_DAY;

    UCAL_IS_LEAP_MONTH        :: IS_LEAP_MONTH;

    UCAL_ORDINAL_MONTH        :: ORDINAL_MONTH;

    UCAL_FIELD_COUNT          :: FIELD_COUNT;

    UCAL_DAY_OF_MONTH         :: DAY_OF_MONTH;
}

/**
* Useful constant for days of week. Note: Calendar day-of-week is 1-based. Clients
* who create locale resources for the field of first-day-of-week should be aware of
* this. For instance, in US locale, first-day-of-week is set to 1, i.e., UCAL_SUNDAY.
*/
/** Possible days of the week in a UCalendar
* @stable ICU 2.0
*/
UCalendarDaysOfWeek :: enum u32 {
    SUNDAY    :: 1;

    MONDAY    :: 2;

    TUESDAY   :: 3;

    WEDNESDAY :: 4;

    THURSDAY  :: 5;

    FRIDAY    :: 6;

    SATURDAY  :: 7;

    UCAL_SUNDAY    :: SUNDAY;

    UCAL_MONDAY    :: MONDAY;

    UCAL_TUESDAY   :: TUESDAY;

    UCAL_WEDNESDAY :: WEDNESDAY;

    UCAL_THURSDAY  :: THURSDAY;

    UCAL_FRIDAY    :: FRIDAY;

    UCAL_SATURDAY  :: SATURDAY;
}

/** Possible months in a UCalendar. Note: Calendar month is 0-based.
* @stable ICU 2.0
*/
UCalendarMonths :: enum u32 {
    JANUARY    :: 0;

    FEBRUARY   :: 1;

    MARCH      :: 2;

    APRIL      :: 3;

    MAY        :: 4;

    JUNE       :: 5;

    JULY       :: 6;

    AUGUST     :: 7;

    SEPTEMBER  :: 8;

    OCTOBER    :: 9;

    NOVEMBER   :: 10;

    DECEMBER   :: 11;

    UNDECIMBER :: 12;

    UCAL_JANUARY    :: JANUARY;

    UCAL_FEBRUARY   :: FEBRUARY;

    UCAL_MARCH      :: MARCH;

    UCAL_APRIL      :: APRIL;

    UCAL_MAY        :: MAY;

    UCAL_JUNE       :: JUNE;

    UCAL_JULY       :: JULY;

    UCAL_AUGUST     :: AUGUST;

    UCAL_SEPTEMBER  :: SEPTEMBER;

    UCAL_OCTOBER    :: OCTOBER;

    UCAL_NOVEMBER   :: NOVEMBER;

    UCAL_DECEMBER   :: DECEMBER;

    UCAL_UNDECIMBER :: UNDECIMBER;
}

/** Possible AM/PM values in a UCalendar
* @stable ICU 2.0
*/
UCalendarAMPMs :: enum u32 {
    AM :: 0;

    PM :: 1;

    UCAL_AM :: AM;

    UCAL_PM :: PM;
}

/**
* System time zone type constants used by filtering zones
* in ucal_openTimeZoneIDEnumeration.
* @see ucal_openTimeZoneIDEnumeration
* @stable ICU 4.8
*/
USystemTimeZoneType :: enum u32 {
    ANY                :: 0;

    CANONICAL          :: 1;

    CANONICAL_LOCATION :: 2;

    UCAL_ZONE_TYPE_ANY                :: ANY;

    UCAL_ZONE_TYPE_CANONICAL          :: CANONICAL;

    UCAL_ZONE_TYPE_CANONICAL_LOCATION :: CANONICAL_LOCATION;
}

ucal_openTimeZoneIDEnumeration :: (zoneType: USystemTimeZoneType, region: *u8, rawOffset: *s32, ec: *UErrorCode) -> *UEnumeration #foreign libicutu "ucal_openTimeZoneIDEnumeration_73";

ucal_openTimeZones :: (ec: *UErrorCode) -> *UEnumeration #foreign libicutu "ucal_openTimeZones_73";

ucal_openCountryTimeZones :: (country: *u8, ec: *UErrorCode) -> *UEnumeration #foreign libicutu "ucal_openCountryTimeZones_73";

ucal_getDefaultTimeZone :: (result: *UChar, resultCapacity: s32, ec: *UErrorCode) -> s32 #foreign libicutu "ucal_getDefaultTimeZone_73";

ucal_setDefaultTimeZone :: (zoneID: *UChar, ec: *UErrorCode) -> void #foreign libicutu "ucal_setDefaultTimeZone_73";

ucal_getHostTimeZone :: (result: *UChar, resultCapacity: s32, ec: *UErrorCode) -> s32 #foreign libicutu "ucal_getHostTimeZone_73";

ucal_getDSTSavings :: (zoneID: *UChar, ec: *UErrorCode) -> s32 #foreign libicutu "ucal_getDSTSavings_73";

ucal_getNow :: () -> UDate #foreign libicutu "ucal_getNow_73";

ucal_open :: (zoneID: *UChar, len: s32, locale: *u8, type: UCalendarType, status: *UErrorCode) -> *UCalendar #foreign libicutu "ucal_open_73";

ucal_close :: (cal: *UCalendar) -> void #foreign libicutu "ucal_close_73";

ucal_clone :: (cal: *UCalendar, status: *UErrorCode) -> *UCalendar #foreign libicutu "ucal_clone_73";

ucal_setTimeZone :: (cal: *UCalendar, zoneID: *UChar, len: s32, status: *UErrorCode) -> void #foreign libicutu "ucal_setTimeZone_73";

ucal_getTimeZoneID :: (cal: *UCalendar, result: *UChar, resultLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getTimeZoneID_73";

/**
* Possible formats for a UCalendar's display name
* @stable ICU 2.0
*/
UCalendarDisplayNameType :: enum u32 {
    STANDARD       :: 0;

    SHORT_STANDARD :: 1;

    DST            :: 2;

    SHORT_DST      :: 3;

    UCAL_STANDARD       :: STANDARD;

    UCAL_SHORT_STANDARD :: SHORT_STANDARD;

    UCAL_DST            :: DST;

    UCAL_SHORT_DST      :: SHORT_DST;
}

ucal_getTimeZoneDisplayName :: (cal: *UCalendar, type: UCalendarDisplayNameType, locale: *u8, result: *UChar, resultLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getTimeZoneDisplayName_73";

ucal_inDaylightTime :: (cal: *UCalendar, status: *UErrorCode) -> UBool #foreign libicutu "ucal_inDaylightTime_73";

ucal_setGregorianChange :: (cal: *UCalendar, date: UDate, pErrorCode: *UErrorCode) -> void #foreign libicutu "ucal_setGregorianChange_73";

ucal_getGregorianChange :: (cal: *UCalendar, pErrorCode: *UErrorCode) -> UDate #foreign libicutu "ucal_getGregorianChange_73";

/**
* Types of UCalendar attributes
* @stable ICU 2.0
*/
UCalendarAttribute :: enum u32 {
    LENIENT                    :: 0;

    FIRST_DAY_OF_WEEK          :: 1;

    MINIMAL_DAYS_IN_FIRST_WEEK :: 2;

    REPEATED_WALL_TIME         :: 3;

    SKIPPED_WALL_TIME          :: 4;

    UCAL_LENIENT                    :: LENIENT;

    UCAL_FIRST_DAY_OF_WEEK          :: FIRST_DAY_OF_WEEK;

    UCAL_MINIMAL_DAYS_IN_FIRST_WEEK :: MINIMAL_DAYS_IN_FIRST_WEEK;

    UCAL_REPEATED_WALL_TIME         :: REPEATED_WALL_TIME;

    UCAL_SKIPPED_WALL_TIME          :: SKIPPED_WALL_TIME;
}

/**
* Options for handling ambiguous wall time at time zone
* offset transitions.
* @stable ICU 49
*/
UCalendarWallTimeOption :: enum u32 {
    LAST       :: 0;

    FIRST      :: 1;

    NEXT_VALID :: 2;

    UCAL_WALLTIME_LAST       :: LAST;

    UCAL_WALLTIME_FIRST      :: FIRST;

    UCAL_WALLTIME_NEXT_VALID :: NEXT_VALID;
}

ucal_getAttribute :: (cal: *UCalendar, attr: UCalendarAttribute) -> s32 #foreign libicutu "ucal_getAttribute_73";

ucal_setAttribute :: (cal: *UCalendar, attr: UCalendarAttribute, newValue: s32) -> void #foreign libicutu "ucal_setAttribute_73";

ucal_getAvailable :: (localeIndex: s32) -> *u8 #foreign libicutu "ucal_getAvailable_73";

ucal_countAvailable :: () -> s32 #foreign libicutu "ucal_countAvailable_73";

ucal_getMillis :: (cal: *UCalendar, status: *UErrorCode) -> UDate #foreign libicutu "ucal_getMillis_73";

ucal_setMillis :: (cal: *UCalendar, dateTime: UDate, status: *UErrorCode) -> void #foreign libicutu "ucal_setMillis_73";

ucal_setDate :: (cal: *UCalendar, year: s32, month: s32, date: s32, status: *UErrorCode) -> void #foreign libicutu "ucal_setDate_73";

ucal_setDateTime :: (cal: *UCalendar, year: s32, month: s32, date: s32, hour: s32, minute: s32, second: s32, status: *UErrorCode) -> void #foreign libicutu "ucal_setDateTime_73";

ucal_equivalentTo :: (cal1: *UCalendar, cal2: *UCalendar) -> UBool #foreign libicutu "ucal_equivalentTo_73";

ucal_add :: (cal: *UCalendar, field: UCalendarDateFields, amount: s32, status: *UErrorCode) -> void #foreign libicutu "ucal_add_73";

ucal_roll :: (cal: *UCalendar, field: UCalendarDateFields, amount: s32, status: *UErrorCode) -> void #foreign libicutu "ucal_roll_73";

ucal_get :: (cal: *UCalendar, field: UCalendarDateFields, status: *UErrorCode) -> s32 #foreign libicutu "ucal_get_73";

ucal_set :: (cal: *UCalendar, field: UCalendarDateFields, value: s32) -> void #foreign libicutu "ucal_set_73";

ucal_isSet :: (cal: *UCalendar, field: UCalendarDateFields) -> UBool #foreign libicutu "ucal_isSet_73";

ucal_clearField :: (cal: *UCalendar, field: UCalendarDateFields) -> void #foreign libicutu "ucal_clearField_73";

ucal_clear :: (calendar: *UCalendar) -> void #foreign libicutu "ucal_clear_73";

/**
* Possible limit values for a UCalendar
* @stable ICU 2.0
*/
UCalendarLimitType :: enum u32 {
    MINIMUM          :: 0;

    MAXIMUM          :: 1;

    GREATEST_MINIMUM :: 2;

    LEAST_MAXIMUM    :: 3;

    ACTUAL_MINIMUM   :: 4;

    ACTUAL_MAXIMUM   :: 5;

    UCAL_MINIMUM          :: MINIMUM;

    UCAL_MAXIMUM          :: MAXIMUM;

    UCAL_GREATEST_MINIMUM :: GREATEST_MINIMUM;

    UCAL_LEAST_MAXIMUM    :: LEAST_MAXIMUM;

    UCAL_ACTUAL_MINIMUM   :: ACTUAL_MINIMUM;

    UCAL_ACTUAL_MAXIMUM   :: ACTUAL_MAXIMUM;
}

ucal_getLimit :: (cal: *UCalendar, field: UCalendarDateFields, type: UCalendarLimitType, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getLimit_73";

ucal_getLocaleByType :: (cal: *UCalendar, type: ULocDataLocaleType, status: *UErrorCode) -> *u8 #foreign libicutu "ucal_getLocaleByType_73";

ucal_getTZDataVersion :: (status: *UErrorCode) -> *u8 #foreign libicutu "ucal_getTZDataVersion_73";

ucal_getCanonicalTimeZoneID :: (id: *UChar, len: s32, result: *UChar, resultCapacity: s32, isSystemID: *UBool, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getCanonicalTimeZoneID_73";

ucal_getType :: (cal: *UCalendar, status: *UErrorCode) -> *u8 #foreign libicutu "ucal_getType_73";

ucal_getKeywordValuesForLocale :: (key: *u8, locale: *u8, commonlyUsed: UBool, status: *UErrorCode) -> *UEnumeration #foreign libicutu "ucal_getKeywordValuesForLocale_73";

/** Weekday types, as returned by ucal_getDayOfWeekType().
* @stable ICU 4.4
*/
UCalendarWeekdayType :: enum u32 {
    WEEKDAY       :: 0;

    WEEKEND       :: 1;

    WEEKEND_ONSET :: 2;

    WEEKEND_CEASE :: 3;

    UCAL_WEEKDAY       :: WEEKDAY;

    UCAL_WEEKEND       :: WEEKEND;

    UCAL_WEEKEND_ONSET :: WEEKEND_ONSET;

    UCAL_WEEKEND_CEASE :: WEEKEND_CEASE;
}

ucal_getDayOfWeekType :: (cal: *UCalendar, dayOfWeek: UCalendarDaysOfWeek, status: *UErrorCode) -> UCalendarWeekdayType #foreign libicutu "ucal_getDayOfWeekType_73";

ucal_getWeekendTransition :: (cal: *UCalendar, dayOfWeek: UCalendarDaysOfWeek, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getWeekendTransition_73";

ucal_isWeekend :: (cal: *UCalendar, date: UDate, status: *UErrorCode) -> UBool #foreign libicutu "ucal_isWeekend_73";

ucal_getFieldDifference :: (cal: *UCalendar, target: UDate, field: UCalendarDateFields, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getFieldDifference_73";

/**
* Time zone transition types for ucal_getTimeZoneTransitionDate
* @stable ICU 50
*/
UTimeZoneTransitionType :: enum u32 {
    NEXT               :: 0;

    NEXT_INCLUSIVE     :: 1;

    PREVIOUS           :: 2;

    PREVIOUS_INCLUSIVE :: 3;

    UCAL_TZ_TRANSITION_NEXT               :: NEXT;

    UCAL_TZ_TRANSITION_NEXT_INCLUSIVE     :: NEXT_INCLUSIVE;

    UCAL_TZ_TRANSITION_PREVIOUS           :: PREVIOUS;

    UCAL_TZ_TRANSITION_PREVIOUS_INCLUSIVE :: PREVIOUS_INCLUSIVE;
}

ucal_getTimeZoneTransitionDate :: (cal: *UCalendar, type: UTimeZoneTransitionType, transition: *UDate, status: *UErrorCode) -> UBool #foreign libicutu "ucal_getTimeZoneTransitionDate_73";

ucal_getWindowsTimeZoneID :: (id: *UChar, len: s32, winid: *UChar, winidCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getWindowsTimeZoneID_73";

ucal_getTimeZoneIDForWindowsID :: (winid: *UChar, len: s32, region: *u8, id: *UChar, idCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getTimeZoneIDForWindowsID_73";

/**
* Options used by ucal_getTimeZoneOffsetFromLocal and BasicTimeZone::getOffsetFromLocal()
* to specify how to interpret an input time when it does not exist, or when it is ambiguous,
* around a time zone transition.
* @stable ICU 69
*/
UTimeZoneLocalOption :: enum u32 {
    FORMER          :: 4;

    LATTER          :: 12;

    STANDARD_FORMER :: 5;

    STANDARD_LATTER :: 13;

    DAYLIGHT_FORMER :: 7;

    DAYLIGHT_LATTER :: 15;

    UCAL_TZ_LOCAL_FORMER          :: FORMER;

    UCAL_TZ_LOCAL_LATTER          :: LATTER;

    UCAL_TZ_LOCAL_STANDARD_FORMER :: STANDARD_FORMER;

    UCAL_TZ_LOCAL_STANDARD_LATTER :: STANDARD_LATTER;

    UCAL_TZ_LOCAL_DAYLIGHT_FORMER :: DAYLIGHT_FORMER;

    UCAL_TZ_LOCAL_DAYLIGHT_LATTER :: DAYLIGHT_LATTER;
}

ucal_getTimeZoneOffsetFromLocal :: (cal: *UCalendar, nonExistingTimeOpt: UTimeZoneLocalOption, duplicatedTimeOpt: UTimeZoneLocalOption, rawOffset: *s32, dstOffset: *s32, status: *UErrorCode) -> void #foreign libicutu "ucal_getTimeZoneOffsetFromLocal_73";

u_getDataDirectory :: () -> *u8 #foreign libicutu "u_getDataDirectory_73";

u_setDataDirectory :: (directory: *u8) -> void #foreign libicutu "u_setDataDirectory_73";

u_getTimeZoneFilesDirectory :: (status: *UErrorCode) -> *u8 #foreign libicutu "u_getTimeZoneFilesDirectory_73";

u_setTimeZoneFilesDirectory :: (path: *u8, status: *UErrorCode) -> void #foreign libicutu "u_setTimeZoneFilesDirectory_73";

u_charsToUChars :: (cs: *u8, us: *UChar, length: s32) -> void #foreign libicutu "u_charsToUChars_73";

u_UCharsToChars :: (us: *UChar, cs: *u8, length: s32) -> void #foreign libicutu "u_UCharsToChars_73";

/**
* Origin constants for UCharIterator.getIndex() and UCharIterator.move().
* @see UCharIteratorMove
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorOrigin :: enum u32 {
    START   :: 0;
    CURRENT :: 1;
    LIMIT   :: 2;
    ZERO    :: 3;
    LENGTH  :: 4;
    UITER_START   :: START;
    UITER_CURRENT :: CURRENT;
    UITER_LIMIT   :: LIMIT;
    UITER_ZERO    :: ZERO;
    UITER_LENGTH  :: LENGTH;
}

/** Constants for UCharIterator. @stable ICU 2.6 */
anon_enum :: enum s32 {
    UITER_UNKNOWN_INDEX :: -2;
}

/**
* Function type declaration for UCharIterator.getIndex().
*
* Gets the current position, or the start or limit of the
* iteration range.
*
* This function may perform slowly for UITER_CURRENT after setState() was called,
* or for UITER_LENGTH, because an iterator implementation may have to count
* UChars if the underlying storage is not UTF-16.
*
* @param iter the UCharIterator structure ("this pointer")
* @param origin get the 0, start, limit, length, or current index
* @return the requested index, or U_SENTINEL in an error condition
*
* @see UCharIteratorOrigin
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorGetIndex :: #type (iter: *UCharIterator, origin: UCharIteratorOrigin) -> s32 #c_call;

/**
* Function type declaration for UCharIterator.move().
*
* Use iter->move(iter, index, UITER_ZERO) like CharacterIterator::setIndex(index).
*
* Moves the current position relative to the start or limit of the
* iteration range, or relative to the current position itself.
* The movement is expressed in numbers of code units forward
* or backward by specifying a positive or negative delta.
* Out of bounds movement will be pinned to the start or limit.
*
* This function may perform slowly for moving relative to UITER_LENGTH
* because an iterator implementation may have to count the rest of the
* UChars if the native storage is not UTF-16.
*
* When moving relative to the limit or length, or
* relative to the current position after setState() was called,
* move() may return UITER_UNKNOWN_INDEX (-2) to avoid an inefficient
* determination of the actual UTF-16 index.
* The actual index can be determined with getIndex(UITER_CURRENT)
* which will count the UChars if necessary.
* See UITER_UNKNOWN_INDEX for details.
*
* @param iter the UCharIterator structure ("this pointer")
* @param delta can be positive, zero, or negative
* @param origin move relative to the 0, start, limit, length, or current index
* @return the new index, or U_SENTINEL on an error condition,
*         or UITER_UNKNOWN_INDEX when the index is not known.
*
* @see UCharIteratorOrigin
* @see UCharIterator
* @see UITER_UNKNOWN_INDEX
* @stable ICU 2.1
*/
UCharIteratorMove :: #type (iter: *UCharIterator, delta: s32, origin: UCharIteratorOrigin) -> s32 #c_call;

/**
* Function type declaration for UCharIterator.hasNext().
*
* Check if current() and next() can still
* return another code unit.
*
* @param iter the UCharIterator structure ("this pointer")
* @return boolean value for whether current() and next() can still return another code unit
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorHasNext :: #type (iter: *UCharIterator) -> UBool #c_call;

/**
* Function type declaration for UCharIterator.hasPrevious().
*
* Check if previous() can still return another code unit.
*
* @param iter the UCharIterator structure ("this pointer")
* @return boolean value for whether previous() can still return another code unit
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorHasPrevious :: #type (iter: *UCharIterator) -> UBool #c_call;

/**
* Function type declaration for UCharIterator.current().
*
* Return the code unit at the current position,
* or U_SENTINEL if there is none (index is at the limit).
*
* @param iter the UCharIterator structure ("this pointer")
* @return the current code unit
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorCurrent :: #type (iter: *UCharIterator) -> UChar32 #c_call;

/**
* Function type declaration for UCharIterator.next().
*
* Return the code unit at the current index and increment
* the index (post-increment, like s[i++]),
* or return U_SENTINEL if there is none (index is at the limit).
*
* @param iter the UCharIterator structure ("this pointer")
* @return the current code unit (and post-increment the current index)
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorNext :: #type (iter: *UCharIterator) -> UChar32 #c_call;

/**
* Function type declaration for UCharIterator.previous().
*
* Decrement the index and return the code unit from there
* (pre-decrement, like s[--i]),
* or return U_SENTINEL if there is none (index is at the start).
*
* @param iter the UCharIterator structure ("this pointer")
* @return the previous code unit (after pre-decrementing the current index)
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorPrevious :: #type (iter: *UCharIterator) -> UChar32 #c_call;

/**
* Function type declaration for UCharIterator.reservedFn().
* Reserved for future use.
*
* @param iter the UCharIterator structure ("this pointer")
* @param something some integer argument
* @return some integer
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorReserved :: #type (iter: *UCharIterator, something: s32) -> s32 #c_call;

/**
* Function type declaration for UCharIterator.getState().
*
* Get the "state" of the iterator in the form of a single 32-bit word.
* It is recommended that the state value be calculated to be as small as
* is feasible. For strings with limited lengths, fewer than 32 bits may
* be sufficient.
*
* This is used together with setState()/UCharIteratorSetState
* to save and restore the iterator position more efficiently than with
* getIndex()/move().
*
* The iterator state is defined as a uint32_t value because it is designed
* for use in ucol_nextSortKeyPart() which provides 32 bits to store the state
* of the character iterator.
*
* With some UCharIterator implementations (e.g., UTF-8),
* getting and setting the UTF-16 index with existing functions
* (getIndex(UITER_CURRENT) followed by move(pos, UITER_ZERO)) is possible but
* relatively slow because the iterator has to "walk" from a known index
* to the requested one.
* This takes more time the farther it needs to go.
*
* An opaque state value allows an iterator implementation to provide
* an internal index (UTF-8: the source byte array index) for
* fast, constant-time restoration.
*
* After calling setState(), a getIndex(UITER_CURRENT) may be slow because
* the UTF-16 index may not be restored as well, but the iterator can deliver
* the correct text contents and move relative to the current position
* without performance degradation.
*
* Some UCharIterator implementations may not be able to return
* a valid state for each position, in which case they return UITER_NO_STATE instead.
* This will be clearly documented for each such iterator (none of the public ones here).
*
* @param iter the UCharIterator structure ("this pointer")
* @return the state word
*
* @see UCharIterator
* @see UCharIteratorSetState
* @see UITER_NO_STATE
* @stable ICU 2.6
*/
UCharIteratorGetState :: #type (iter: *UCharIterator) -> u32 #c_call;

/**
* Function type declaration for UCharIterator.setState().
*
* Restore the "state" of the iterator using a state word from a getState() call.
* The iterator object need not be the same one as for which getState() was called,
* but it must be of the same type (set up using the same uiter_setXYZ function)
* and it must iterate over the same string
* (binary identical regardless of memory address).
* For more about the state word see UCharIteratorGetState.
*
* After calling setState(), a getIndex(UITER_CURRENT) may be slow because
* the UTF-16 index may not be restored as well, but the iterator can deliver
* the correct text contents and move relative to the current position
* without performance degradation.
*
* @param iter the UCharIterator structure ("this pointer")
* @param state the state word from a getState() call
*              on a same-type, same-string iterator
* @param pErrorCode Must be a valid pointer to an error code value,
*                   which must not indicate a failure before the function call.
*
* @see UCharIterator
* @see UCharIteratorGetState
* @stable ICU 2.6
*/
UCharIteratorSetState :: #type (iter: *UCharIterator, state: u32, pErrorCode: *UErrorCode) -> void #c_call;

/**
* C API for code unit iteration.
* This can be used as a C wrapper around
* CharacterIterator, Replaceable, or implemented using simple strings, etc.
*
* There are two roles for using UCharIterator:
*
* A "provider" sets the necessary function pointers and controls the "protected"
* fields of the UCharIterator structure. A "provider" passes a UCharIterator
* into C APIs that need a UCharIterator as an abstract, flexible string interface.
*
* Implementations of such C APIs are "callers" of UCharIterator functions;
* they only use the "public" function pointers and never access the "protected"
* fields directly.
*
* The current() and next() functions only check the current index against the
* limit, and previous() only checks the current index against the start,
* to see if the iterator already reached the end of the iteration range.
*
* The assumption - in all iterators - is that the index is moved via the API,
* which means it won't go out of bounds, or the index is modified by
* user code that knows enough about the iterator implementation to set valid
* index values.
*
* UCharIterator functions return code unit values 0..0xffff,
* or U_SENTINEL if the iteration bounds are reached.
*
* @stable ICU 2.1
*/
UCharIterator :: struct {
    /**
    * (protected) Pointer to string or wrapped object or similar.
    * Not used by caller.
    * @stable ICU 2.1
    */
    _context:      *void;

    /**
    * (protected) Length of string or similar.
    * Not used by caller.
    * @stable ICU 2.1
    */
    length:        s32;

    /**
    * (protected) Start index or similar.
    * Not used by caller.
    * @stable ICU 2.1
    */
    start:         s32;

    /**
    * (protected) Current index or similar.
    * Not used by caller.
    * @stable ICU 2.1
    */
    index:         s32;

    /**
    * (protected) Limit index or similar.
    * Not used by caller.
    * @stable ICU 2.1
    */
    limit:         s32;

    /**
    * (protected) Used by UTF-8 iterators and possibly others.
    * @stable ICU 2.1
    */
    reservedField: s32;

    /**
    * (public) Returns the current position or the
    * start or limit index of the iteration range.
    *
    * @see UCharIteratorGetIndex
    * @stable ICU 2.1
    */
    getIndex:      UCharIteratorGetIndex;

    /**
    * (public) Moves the current position relative to the start or limit of the
    * iteration range, or relative to the current position itself.
    * The movement is expressed in numbers of code units forward
    * or backward by specifying a positive or negative delta.
    *
    * @see UCharIteratorMove
    * @stable ICU 2.1
    */
    move:          UCharIteratorMove;

    /**
    * (public) Check if current() and next() can still
    * return another code unit.
    *
    * @see UCharIteratorHasNext
    * @stable ICU 2.1
    */
    hasNext:       UCharIteratorHasNext;

    /**
    * (public) Check if previous() can still return another code unit.
    *
    * @see UCharIteratorHasPrevious
    * @stable ICU 2.1
    */
    hasPrevious:   UCharIteratorHasPrevious;

    /**
    * (public) Return the code unit at the current position,
    * or U_SENTINEL if there is none (index is at the limit).
    *
    * @see UCharIteratorCurrent
    * @stable ICU 2.1
    */
    current:       UCharIteratorCurrent;

    /**
    * (public) Return the code unit at the current index and increment
    * the index (post-increment, like s[i++]),
    * or return U_SENTINEL if there is none (index is at the limit).
    *
    * @see UCharIteratorNext
    * @stable ICU 2.1
    */
    next:          UCharIteratorNext;

    /**
    * (public) Decrement the index and return the code unit from there
    * (pre-decrement, like s[--i]),
    * or return U_SENTINEL if there is none (index is at the start).
    *
    * @see UCharIteratorPrevious
    * @stable ICU 2.1
    */
    previous:      UCharIteratorPrevious;

    /**
    * (public) Reserved for future use. Currently NULL.
    *
    * @see UCharIteratorReserved
    * @stable ICU 2.1
    */
    reservedFn:    UCharIteratorReserved;

    /**
    * (public) Return the state of the iterator, to be restored later with setState().
    * This function pointer is NULL if the iterator does not implement it.
    *
    * @see UCharIteratorGet
    * @stable ICU 2.6
    */
    getState:      UCharIteratorGetState;

    /**
    * (public) Restore the iterator state from the state word from a call
    * to getState().
    * This function pointer is NULL if the iterator does not implement it.
    *
    * @see UCharIteratorSet
    * @stable ICU 2.6
    */
    setState:      UCharIteratorSetState;
}

uiter_current32 :: (iter: *UCharIterator) -> UChar32 #foreign libicutu "uiter_current32_73";

uiter_next32 :: (iter: *UCharIterator) -> UChar32 #foreign libicutu "uiter_next32_73";

uiter_previous32 :: (iter: *UCharIterator) -> UChar32 #foreign libicutu "uiter_previous32_73";

uiter_getState :: (iter: *UCharIterator) -> u32 #foreign libicutu "uiter_getState_73";

uiter_setState :: (iter: *UCharIterator, state: u32, pErrorCode: *UErrorCode) -> void #foreign libicutu "uiter_setState_73";

uiter_setString :: (iter: *UCharIterator, s: *UChar, length: s32) -> void #foreign libicutu "uiter_setString_73";

uiter_setUTF16BE :: (iter: *UCharIterator, s: *u8, length: s32) -> void #foreign libicutu "uiter_setUTF16BE_73";

uiter_setUTF8 :: (iter: *UCharIterator, s: *u8, length: s32) -> void #foreign libicutu "uiter_setUTF8_73";

UBreakIterator :: struct {}

u_strlen :: (s: *UChar) -> s32 #foreign libicutu "u_strlen_73";

u_countChar32 :: (s: *UChar, length: s32) -> s32 #foreign libicutu "u_countChar32_73";

u_strHasMoreChar32Than :: (s: *UChar, length: s32, number: s32) -> UBool #foreign libicutu "u_strHasMoreChar32Than_73";

u_strcat :: (dst: *UChar, src: *UChar) -> *UChar #foreign libicutu "u_strcat_73";

u_strncat :: (dst: *UChar, src: *UChar, n: s32) -> *UChar #foreign libicutu "u_strncat_73";

u_strstr :: (s: *UChar, substring: *UChar) -> *UChar #foreign libicutu "u_strstr_73";

u_strFindFirst :: (s: *UChar, length: s32, substring: *UChar, subLength: s32) -> *UChar #foreign libicutu "u_strFindFirst_73";

u_strchr :: (s: *UChar, c: UChar) -> *UChar #foreign libicutu "u_strchr_73";

u_strchr32 :: (s: *UChar, c: UChar32) -> *UChar #foreign libicutu "u_strchr32_73";

u_strrstr :: (s: *UChar, substring: *UChar) -> *UChar #foreign libicutu "u_strrstr_73";

u_strFindLast :: (s: *UChar, length: s32, substring: *UChar, subLength: s32) -> *UChar #foreign libicutu "u_strFindLast_73";

u_strrchr :: (s: *UChar, c: UChar) -> *UChar #foreign libicutu "u_strrchr_73";

u_strrchr32 :: (s: *UChar, c: UChar32) -> *UChar #foreign libicutu "u_strrchr32_73";

u_strpbrk :: (_string: *UChar, matchSet: *UChar) -> *UChar #foreign libicutu "u_strpbrk_73";

u_strcspn :: (_string: *UChar, matchSet: *UChar) -> s32 #foreign libicutu "u_strcspn_73";

u_strspn :: (_string: *UChar, matchSet: *UChar) -> s32 #foreign libicutu "u_strspn_73";

u_strtok_r :: (src: *UChar, delim: *UChar, saveState: **UChar) -> *UChar #foreign libicutu "u_strtok_r_73";

u_strcmp :: (s1: *UChar, s2: *UChar) -> s32 #foreign libicutu "u_strcmp_73";

u_strcmpCodePointOrder :: (s1: *UChar, s2: *UChar) -> s32 #foreign libicutu "u_strcmpCodePointOrder_73";

u_strCompare :: (s1: *UChar, length1: s32, s2: *UChar, length2: s32, codePointOrder: UBool) -> s32 #foreign libicutu "u_strCompare_73";

u_strCompareIter :: (iter1: *UCharIterator, iter2: *UCharIterator, codePointOrder: UBool) -> s32 #foreign libicutu "u_strCompareIter_73";

u_strCaseCompare :: (s1: *UChar, length1: s32, s2: *UChar, length2: s32, options: u32, pErrorCode: *UErrorCode) -> s32 #foreign libicutu "u_strCaseCompare_73";

u_strncmp :: (ucs1: *UChar, ucs2: *UChar, n: s32) -> s32 #foreign libicutu "u_strncmp_73";

u_strncmpCodePointOrder :: (s1: *UChar, s2: *UChar, n: s32) -> s32 #foreign libicutu "u_strncmpCodePointOrder_73";

u_strcasecmp :: (s1: *UChar, s2: *UChar, options: u32) -> s32 #foreign libicutu "u_strcasecmp_73";

u_strncasecmp :: (s1: *UChar, s2: *UChar, n: s32, options: u32) -> s32 #foreign libicutu "u_strncasecmp_73";

u_memcasecmp :: (s1: *UChar, s2: *UChar, length: s32, options: u32) -> s32 #foreign libicutu "u_memcasecmp_73";

u_strcpy :: (dst: *UChar, src: *UChar) -> *UChar #foreign libicutu "u_strcpy_73";

u_strncpy :: (dst: *UChar, src: *UChar, n: s32) -> *UChar #foreign libicutu "u_strncpy_73";

u_uastrcpy :: (dst: *UChar, src: *u8) -> *UChar #foreign libicutu "u_uastrcpy_73";

u_uastrncpy :: (dst: *UChar, src: *u8, n: s32) -> *UChar #foreign libicutu "u_uastrncpy_73";

u_austrcpy :: (dst: *u8, src: *UChar) -> *u8 #foreign libicutu "u_austrcpy_73";

u_austrncpy :: (dst: *u8, src: *UChar, n: s32) -> *u8 #foreign libicutu "u_austrncpy_73";

u_memcpy :: (dest: *UChar, src: *UChar, count: s32) -> *UChar #foreign libicutu "u_memcpy_73";

u_memmove :: (dest: *UChar, src: *UChar, count: s32) -> *UChar #foreign libicutu "u_memmove_73";

u_memset :: (dest: *UChar, c: UChar, count: s32) -> *UChar #foreign libicutu "u_memset_73";

u_memcmp :: (buf1: *UChar, buf2: *UChar, count: s32) -> s32 #foreign libicutu "u_memcmp_73";

u_memcmpCodePointOrder :: (s1: *UChar, s2: *UChar, count: s32) -> s32 #foreign libicutu "u_memcmpCodePointOrder_73";

u_memchr :: (s: *UChar, c: UChar, count: s32) -> *UChar #foreign libicutu "u_memchr_73";

u_memchr32 :: (s: *UChar, c: UChar32, count: s32) -> *UChar #foreign libicutu "u_memchr32_73";

u_memrchr :: (s: *UChar, c: UChar, count: s32) -> *UChar #foreign libicutu "u_memrchr_73";

u_memrchr32 :: (s: *UChar, c: UChar32, count: s32) -> *UChar #foreign libicutu "u_memrchr32_73";

u_unescape :: (src: *u8, dest: *UChar, destCapacity: s32) -> s32 #foreign libicutu "u_unescape_73";

/**
* Callback function for u_unescapeAt() that returns a character of
* the source text given an offset and a context pointer.  The context
* pointer will be whatever is passed into u_unescapeAt().
*
* @param offset pointer to the offset that will be passed to u_unescapeAt().
* @param context an opaque pointer passed directly into u_unescapeAt()
* @return the character represented by the escape sequence at
* offset
* @see u_unescapeAt
* @stable ICU 2.0
*/
UNESCAPE_CHAR_AT :: #type (offset: s32, _context: *void) -> UChar #c_call;

u_unescapeAt :: (charAt: UNESCAPE_CHAR_AT, offset: *s32, length: s32, _context: *void) -> UChar32 #foreign libicutu "u_unescapeAt_73";

u_strToUpper :: (dest: *UChar, destCapacity: s32, src: *UChar, srcLength: s32, locale: *u8, pErrorCode: *UErrorCode) -> s32 #foreign libicutu "u_strToUpper_73";

u_strToLower :: (dest: *UChar, destCapacity: s32, src: *UChar, srcLength: s32, locale: *u8, pErrorCode: *UErrorCode) -> s32 #foreign libicutu "u_strToLower_73";

u_strToTitle :: (dest: *UChar, destCapacity: s32, src: *UChar, srcLength: s32, titleIter: *UBreakIterator, locale: *u8, pErrorCode: *UErrorCode) -> s32 #foreign libicutu "u_strToTitle_73";

u_strFoldCase :: (dest: *UChar, destCapacity: s32, src: *UChar, srcLength: s32, options: u32, pErrorCode: *UErrorCode) -> s32 #foreign libicutu "u_strFoldCase_73";

u_strToWCS :: (dest: *wchar_t, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, pErrorCode: *UErrorCode) -> *wchar_t #foreign libicutu "u_strToWCS_73";

u_strFromWCS :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *wchar_t, srcLength: s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromWCS_73";

u_strToUTF8 :: (dest: *u8, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, pErrorCode: *UErrorCode) -> *u8 #foreign libicutu "u_strToUTF8_73";

u_strFromUTF8 :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *u8, srcLength: s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromUTF8_73";

u_strToUTF8WithSub :: (dest: *u8, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, subchar: UChar32, pNumSubstitutions: *s32, pErrorCode: *UErrorCode) -> *u8 #foreign libicutu "u_strToUTF8WithSub_73";

u_strFromUTF8WithSub :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *u8, srcLength: s32, subchar: UChar32, pNumSubstitutions: *s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromUTF8WithSub_73";

u_strFromUTF8Lenient :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *u8, srcLength: s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromUTF8Lenient_73";

u_strToUTF32 :: (dest: *UChar32, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, pErrorCode: *UErrorCode) -> *UChar32 #foreign libicutu "u_strToUTF32_73";

u_strFromUTF32 :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *UChar32, srcLength: s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromUTF32_73";

u_strToUTF32WithSub :: (dest: *UChar32, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, subchar: UChar32, pNumSubstitutions: *s32, pErrorCode: *UErrorCode) -> *UChar32 #foreign libicutu "u_strToUTF32WithSub_73";

u_strFromUTF32WithSub :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *UChar32, srcLength: s32, subchar: UChar32, pNumSubstitutions: *s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromUTF32WithSub_73";

u_strToJavaModifiedUTF8 :: (dest: *u8, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, pErrorCode: *UErrorCode) -> *u8 #foreign libicutu "u_strToJavaModifiedUTF8_73";

u_strFromJavaModifiedUTF8WithSub :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *u8, srcLength: s32, subchar: UChar32, pNumSubstitutions: *s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromJavaModifiedUTF8WithSub_73";

#scope_file

#import "Basic"; // For assert

libicutu :: #library "/usr/local/homebrew/Cellar/icu4c/73.2/lib/libicutu";
libicuuc :: #library "/usr/local/homebrew/Cellar/icu4c/73.2/lib/libicuuc";
libicui18n :: #library "/usr/local/homebrew/Cellar/icu4c/73.2/lib/libicui18n";
libicudata :: #library "/usr/local/homebrew/Cellar/icu4c/73.2/lib/libicudata";

#run {
    {
        instance: UCharIterator;
        assert(((cast(*void)(*instance._context)) - cast(*void)(*instance)) == 0, "UCharIterator._context has unexpected offset % instead of 0", ((cast(*void)(*instance._context)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator._context)) == 8, "UCharIterator._context has unexpected size % instead of 8", size_of(type_of(UCharIterator._context)));
        assert(((cast(*void)(*instance.length)) - cast(*void)(*instance)) == 8, "UCharIterator.length has unexpected offset % instead of 8", ((cast(*void)(*instance.length)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.length)) == 4, "UCharIterator.length has unexpected size % instead of 4", size_of(type_of(UCharIterator.length)));
        assert(((cast(*void)(*instance.start)) - cast(*void)(*instance)) == 12, "UCharIterator.start has unexpected offset % instead of 12", ((cast(*void)(*instance.start)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.start)) == 4, "UCharIterator.start has unexpected size % instead of 4", size_of(type_of(UCharIterator.start)));
        assert(((cast(*void)(*instance.index)) - cast(*void)(*instance)) == 16, "UCharIterator.index has unexpected offset % instead of 16", ((cast(*void)(*instance.index)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.index)) == 4, "UCharIterator.index has unexpected size % instead of 4", size_of(type_of(UCharIterator.index)));
        assert(((cast(*void)(*instance.limit)) - cast(*void)(*instance)) == 20, "UCharIterator.limit has unexpected offset % instead of 20", ((cast(*void)(*instance.limit)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.limit)) == 4, "UCharIterator.limit has unexpected size % instead of 4", size_of(type_of(UCharIterator.limit)));
        assert(((cast(*void)(*instance.reservedField)) - cast(*void)(*instance)) == 24, "UCharIterator.reservedField has unexpected offset % instead of 24", ((cast(*void)(*instance.reservedField)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.reservedField)) == 4, "UCharIterator.reservedField has unexpected size % instead of 4", size_of(type_of(UCharIterator.reservedField)));
        assert(((cast(*void)(*instance.getIndex)) - cast(*void)(*instance)) == 32, "UCharIterator.getIndex has unexpected offset % instead of 32", ((cast(*void)(*instance.getIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.getIndex)) == 8, "UCharIterator.getIndex has unexpected size % instead of 8", size_of(type_of(UCharIterator.getIndex)));
        assert(((cast(*void)(*instance.move)) - cast(*void)(*instance)) == 40, "UCharIterator.move has unexpected offset % instead of 40", ((cast(*void)(*instance.move)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.move)) == 8, "UCharIterator.move has unexpected size % instead of 8", size_of(type_of(UCharIterator.move)));
        assert(((cast(*void)(*instance.hasNext)) - cast(*void)(*instance)) == 48, "UCharIterator.hasNext has unexpected offset % instead of 48", ((cast(*void)(*instance.hasNext)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.hasNext)) == 8, "UCharIterator.hasNext has unexpected size % instead of 8", size_of(type_of(UCharIterator.hasNext)));
        assert(((cast(*void)(*instance.hasPrevious)) - cast(*void)(*instance)) == 56, "UCharIterator.hasPrevious has unexpected offset % instead of 56", ((cast(*void)(*instance.hasPrevious)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.hasPrevious)) == 8, "UCharIterator.hasPrevious has unexpected size % instead of 8", size_of(type_of(UCharIterator.hasPrevious)));
        assert(((cast(*void)(*instance.current)) - cast(*void)(*instance)) == 64, "UCharIterator.current has unexpected offset % instead of 64", ((cast(*void)(*instance.current)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.current)) == 8, "UCharIterator.current has unexpected size % instead of 8", size_of(type_of(UCharIterator.current)));
        assert(((cast(*void)(*instance.next)) - cast(*void)(*instance)) == 72, "UCharIterator.next has unexpected offset % instead of 72", ((cast(*void)(*instance.next)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.next)) == 8, "UCharIterator.next has unexpected size % instead of 8", size_of(type_of(UCharIterator.next)));
        assert(((cast(*void)(*instance.previous)) - cast(*void)(*instance)) == 80, "UCharIterator.previous has unexpected offset % instead of 80", ((cast(*void)(*instance.previous)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.previous)) == 8, "UCharIterator.previous has unexpected size % instead of 8", size_of(type_of(UCharIterator.previous)));
        assert(((cast(*void)(*instance.reservedFn)) - cast(*void)(*instance)) == 88, "UCharIterator.reservedFn has unexpected offset % instead of 88", ((cast(*void)(*instance.reservedFn)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.reservedFn)) == 8, "UCharIterator.reservedFn has unexpected size % instead of 8", size_of(type_of(UCharIterator.reservedFn)));
        assert(((cast(*void)(*instance.getState)) - cast(*void)(*instance)) == 96, "UCharIterator.getState has unexpected offset % instead of 96", ((cast(*void)(*instance.getState)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.getState)) == 8, "UCharIterator.getState has unexpected size % instead of 8", size_of(type_of(UCharIterator.getState)));
        assert(((cast(*void)(*instance.setState)) - cast(*void)(*instance)) == 104, "UCharIterator.setState has unexpected offset % instead of 104", ((cast(*void)(*instance.setState)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.setState)) == 8, "UCharIterator.setState has unexpected size % instead of 8", size_of(type_of(UCharIterator.setState)));
        assert(size_of(UCharIterator) == 112, "UCharIterator has size % instead of 112", size_of(UCharIterator));
    }
}

