//
// This file was auto-generated using the following command:
//
// jai generate.jai
//



U_DEBUG :: 0;

UCLN_NO_AUTO_CLEANUP :: 1;

U_DISABLE_RENAMING :: 0;

U_NO_DEFAULT_INCLUDE_UTF_HEADERS :: 0;

U_OVERRIDE_CXX_ALLOCATION :: 1;

U_ENABLE_TRACING :: 0;

UCONFIG_ENABLE_PLUGINS :: 0;

U_ENABLE_DYLOAD :: 1;

U_CHECK_DYLOAD :: 1;

U_DEFAULT_SHOW_DRAFT :: 1;

U_LIB_SUFFIX_C_NAME_STRING :: "";

UCONFIG_ONLY_COLLATION :: 0;

UCONFIG_NO_FILE_IO :: 0;

UCONFIG_NO_CONVERSION :: 0;

UCONFIG_ONLY_HTML_CONVERSION :: 0;

UCONFIG_NO_LEGACY_CONVERSION :: 0;

UCONFIG_NO_NORMALIZATION :: 0;

UCONFIG_USE_ML_PHRASE_BREAKING :: 0;

UCONFIG_NO_BREAK_ITERATION :: 0;

UCONFIG_NO_IDNA :: 0;

UCONFIG_USE_WINDOWS_LCID_MAPPING_API :: 1;

UCONFIG_NO_COLLATION :: 0;

UCONFIG_NO_FORMATTING :: 0;

UCONFIG_NO_TRANSLITERATION :: 0;

UCONFIG_NO_REGULAR_EXPRESSIONS :: 0;

UCONFIG_NO_SERVICE :: 0;

UCONFIG_HAVE_PARSEALLINPUT :: 1;

UCONFIG_NO_FILTERED_BREAK_ITERATION :: 0;

U_COPYRIGHT_STRING :: " Copyright (C) 2016 and later: Unicode, Inc. and others. License & terms of use: http://www.unicode.org/copyright.html ";

U_ICU_VERSION_MAJOR_NUM :: 73;

U_ICU_VERSION_MINOR_NUM :: 2;

U_ICU_VERSION_PATCHLEVEL_NUM :: 0;

U_ICU_VERSION_BUILDLEVEL_NUM :: 0;

U_DISABLE_VERSION_SUFFIX :: 0;

U_ICU_VERSION :: "73.2";

U_ICU_VERSION_SHORT :: "73";

U_ICU_DATA_VERSION :: "73.2";

UCOL_RUNTIME_VERSION :: 9;

UCOL_BUILDER_VERSION :: 9;

UCOL_TAILORINGS_VERSION :: 1;

U_PF_UNKNOWN :: 0;

U_PF_WINDOWS :: 1000;

U_PF_MINGW :: 1800;

U_PF_CYGWIN :: 1900;

U_PF_HPUX :: 2100;

U_PF_SOLARIS :: 2600;

U_PF_BSD :: 3000;

U_PF_AIX :: 3100;

U_PF_IRIX :: 3200;

U_PF_DARWIN :: 3500;

U_PF_IPHONE :: 3550;

U_PF_QNX :: 3700;

U_PF_LINUX :: 4000;

U_PF_BROWSER_NATIVE_CLIENT :: 4020;

U_PF_ANDROID :: 4050;

U_PF_FUCHSIA :: 4100;

U_PF_EMSCRIPTEN :: 5010;

U_PF_OS390 :: 9000;

U_PF_OS400 :: 9400;

U_PLATFORM :: U_PF_DARWIN;

U_PLATFORM_USES_ONLY_WIN32_API :: 0;

U_PLATFORM_HAS_WIN32_API :: 0;

U_PLATFORM_HAS_WINUWP_API :: 0;

U_PLATFORM_IMPLEMENTS_POSIX :: 1;

U_PLATFORM_IS_LINUX_BASED :: 0;

U_PLATFORM_IS_DARWIN_BASED :: 1;

U_HAVE_STDINT_H :: 1;

U_HAVE_INTTYPES_H :: U_HAVE_STDINT_H;

U_HAVE_PLACEMENT_NEW :: 1;

U_HAVE_DEBUG_LOCATION_NEW :: 0;

U_CPLUSPLUS_VERSION :: 0;

U_ASCII_FAMILY :: 0;

U_EBCDIC_FAMILY :: 1;

U_CHARSET_FAMILY :: U_ASCII_FAMILY;

U_CHARSET_IS_UTF8 :: 1;

U_HAVE_WCHAR_H :: 1;

U_SIZEOF_WCHAR_T :: 4;

U_HAVE_WCSCPY :: U_HAVE_WCHAR_H;

U_HAVE_CHAR16_T :: 1;

U_DEFINE_FALSE_AND_TRUE :: 0;

U_SIZEOF_UCHAR :: 2;

U_CHAR16_IS_TYPEDEF :: 0;

U_SENTINEL :: -1;

U_COPYRIGHT_STRING_LENGTH :: 128;

U_MAX_VERSION_LENGTH :: 4;

U_MAX_VERSION_STRING_LENGTH :: 20;

U8_LEAD3_T1_BITS :: "\x20\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30\x10\x30\x30";

U8_LEAD4_T1_BITS :: "\x00\x00\x00\x00\x00\x00\x00\x00\x1E\x0F\x0F\x0F\x00\x00\x00\x00";

U8_MAX_LENGTH :: 4;

U16_SURROGATE_OFFSET :: (0xd800<<10)+0xdc00-0x10000;

U16_MAX_LENGTH :: 2;

U_HIDE_OBSOLETE_UTF_OLD_H :: 0;

UTF_SIZE :: 16;

UTF8_ERROR_VALUE_1 :: 0x15;

UTF8_ERROR_VALUE_2 :: 0x9f;

UTF_ERROR_VALUE :: 0xffff;

UTF8_MAX_CHAR_LENGTH :: 4;

UTF_SURROGATE_OFFSET :: (0xd800<<10)+0xdc00-0x10000;

UTF16_MAX_CHAR_LENGTH :: 2;

UTF32_MAX_CHAR_LENGTH :: 1;

UTF_MAX_CHAR_LENGTH :: U16_MAX_LENGTH;

U_SHOW_CPLUSPLUS_API :: 0;

U_ICUDATA_TYPE_LETTER :: "l";

U_USE_USRDATA :: 0;

U_MILLIS_PER_SECOND :: 1000;

U_MILLIS_PER_MINUTE :: 60000;

U_MILLIS_PER_HOUR :: 3600000;

U_MILLIS_PER_DAY :: 86400000;

ULOC_CHINESE :: "zh";

ULOC_ENGLISH :: "en";

ULOC_FRENCH :: "fr";

ULOC_GERMAN :: "de";

ULOC_ITALIAN :: "it";

ULOC_JAPANESE :: "ja";

ULOC_KOREAN :: "ko";

ULOC_SIMPLIFIED_CHINESE :: "zh_CN";

ULOC_TRADITIONAL_CHINESE :: "zh_TW";

ULOC_CANADA :: "en_CA";

ULOC_CANADA_FRENCH :: "fr_CA";

ULOC_CHINA :: "zh_CN";

ULOC_PRC :: "zh_CN";

ULOC_FRANCE :: "fr_FR";

ULOC_GERMANY :: "de_DE";

ULOC_ITALY :: "it_IT";

ULOC_JAPAN :: "ja_JP";

ULOC_KOREA :: "ko_KR";

ULOC_TAIWAN :: "zh_TW";

ULOC_UK :: "en_GB";

ULOC_US :: "en_US";

ULOC_LANG_CAPACITY :: 12;

ULOC_COUNTRY_CAPACITY :: 4;

ULOC_FULLNAME_CAPACITY :: 157;

ULOC_SCRIPT_CAPACITY :: 6;

ULOC_KEYWORDS_CAPACITY :: 96;

ULOC_KEYWORD_AND_VALUES_CAPACITY :: 100;

ULOC_KEYWORD_SEPARATOR_UNICODE :: 0x40;

ULOC_KEYWORD_ASSIGN_UNICODE :: 0x3D;

ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE :: 0x3B;

UCAL_UNKNOWN_ZONE_ID :: "Etc/Unknown";

UDAT_YEAR :: "y";

UDAT_QUARTER :: "QQQQ";

UDAT_ABBR_QUARTER :: "QQQ";

UDAT_YEAR_QUARTER :: "yQQQQ";

UDAT_YEAR_ABBR_QUARTER :: "yQQQ";

UDAT_MONTH :: "MMMM";

UDAT_ABBR_MONTH :: "MMM";

UDAT_NUM_MONTH :: "M";

UDAT_YEAR_MONTH :: "yMMMM";

UDAT_YEAR_ABBR_MONTH :: "yMMM";

UDAT_YEAR_NUM_MONTH :: "yM";

UDAT_DAY :: "d";

UDAT_YEAR_MONTH_DAY :: "yMMMMd";

UDAT_YEAR_ABBR_MONTH_DAY :: "yMMMd";

UDAT_YEAR_NUM_MONTH_DAY :: "yMd";

UDAT_WEEKDAY :: "EEEE";

UDAT_ABBR_WEEKDAY :: "E";

UDAT_YEAR_MONTH_WEEKDAY_DAY :: "yMMMMEEEEd";

UDAT_YEAR_ABBR_MONTH_WEEKDAY_DAY :: "yMMMEd";

UDAT_YEAR_NUM_MONTH_WEEKDAY_DAY :: "yMEd";

UDAT_MONTH_DAY :: "MMMMd";

UDAT_ABBR_MONTH_DAY :: "MMMd";

UDAT_NUM_MONTH_DAY :: "Md";

UDAT_MONTH_WEEKDAY_DAY :: "MMMMEEEEd";

UDAT_ABBR_MONTH_WEEKDAY_DAY :: "MMMEd";

UDAT_NUM_MONTH_WEEKDAY_DAY :: "MEd";

UDAT_HOUR :: "j";

UDAT_HOUR24 :: "H";

UDAT_MINUTE :: "m";

UDAT_HOUR_MINUTE :: "jm";

UDAT_HOUR24_MINUTE :: "Hm";

UDAT_SECOND :: "s";

UDAT_HOUR_MINUTE_SECOND :: "jms";

UDAT_HOUR24_MINUTE_SECOND :: "Hms";

UDAT_MINUTE_SECOND :: "ms";

UDAT_LOCATION_TZ :: "VVVV";

UDAT_GENERIC_TZ :: "vvvv";

UDAT_ABBR_GENERIC_TZ :: "v";

UDAT_SPECIFIC_TZ :: "zzzz";

UDAT_ABBR_SPECIFIC_TZ :: "z";

UDAT_ABBR_UTC_TZ :: "ZZZZ";

UDAT_STANDALONE_MONTH :: "LLLL";

UDAT_ABBR_STANDALONE_MONTH :: "LLL";

UDAT_HOUR_MINUTE_GENERIC_TZ :: "jmv";

UDAT_HOUR_MINUTE_TZ :: "jmz";

UDAT_HOUR_GENERIC_TZ :: "jv";

UDAT_HOUR_TZ :: "jz";

JP_ERA_2019_ROOT :: "Reiwa";

JP_ERA_2019_JA :: "\\u4EE4\\u548C";

JP_ERA_2019_NARROW :: "R";

UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR :: 0;

U_FILE_SEP_STRING :: "/";
U_FILE_ALT_SEP_STRING :: "/";
U_PATH_SEP_STRING :: ":";

UITER_NO_STATE :: cast(u32)0xffffffff;

/**
* The ICU boolean type, a signed-byte integer.
* ICU-specific for historical reasons: The C and C++ standards used to not define type bool.
* Also provides a fixed type definition, as opposed to
* type bool whose details (e.g., sizeof) may vary by compiler and between C and C++.
*
* @stable ICU 2.0
*/
UBool :: s8;

UChar :: u16;

OldUChar :: u16;

/**
* Define UChar32 as a type for single Unicode code points.
* UChar32 is a signed 32-bit integer (same as int32_t).
*
* The Unicode code point range is 0..0x10ffff.
* All other values (negative or >=0x110000) are illegal as Unicode code points.
* They may be used as sentinel values to indicate "done", "error"
* or similar non-code point conditions.
*
* Before ICU 2.4 (Jitterbug 2146), UChar32 was defined
* to be wchar_t if that is 32 bits wide (wchar_t may be signed or unsigned)
* or else to be uint32_t.
* That is, the definition of UChar32 was platform-dependent.
*
* @see U_SENTINEL
* @stable ICU 2.4
*/
UChar32 :: s32;

/** The binary form of a version on ICU APIs is an array of 4 uint8_t.
*  To compare two versions, use memcmp(v1,v2,sizeof(UVersionInfo)).
*  @stable ICU 2.4
*/
UVersionInfo :: [4] u8;

u_versionFromString :: (versionArray: *UVersionInfo, versionString: *u8) -> void #foreign libicutu "u_versionFromString_73";

u_versionFromUString :: (versionArray: *UVersionInfo, versionString: *UChar) -> void #foreign libicutu "u_versionFromUString_73";

u_versionToString :: (versionArray: *UVersionInfo, versionString: *u8) -> void #foreign libicutu "u_versionToString_73";

u_getVersion :: (versionArray: *UVersionInfo) -> void #foreign libicutu "u_getVersion_73";

utf8_nextCharSafeBody :: (s: *u8, pi: *s32, length: s32, c: UChar32, strict: UBool) -> UChar32 #foreign libicutu "utf8_nextCharSafeBody_73";

utf8_appendCharSafeBody :: (s: *u8, i: s32, length: s32, c: UChar32, pIsError: *UBool) -> s32 #foreign libicutu "utf8_appendCharSafeBody_73";

utf8_prevCharSafeBody :: (s: *u8, start: s32, pi: *s32, c: UChar32, strict: UBool) -> UChar32 #foreign libicutu "utf8_prevCharSafeBody_73";

utf8_back1SafeBody :: (s: *u8, start: s32, i: s32) -> s32 #foreign libicutu "utf8_back1SafeBody_73";

utf8_countTrailBytes: *u8 #elsewhere libicutu "utf8_countTrailBytes_73";

/**
* Date and Time data type.
* This is a primitive data type that holds the date and time
* as the number of milliseconds since 1970-jan-01, 00:00 UTC.
* UTC leap seconds are ignored.
* @stable ICU 2.0
*/
UDate :: float64;

/**
* Standard ICU4C error code type, a substitute for exceptions.
*
* Initialize the UErrorCode with U_ZERO_ERROR, and check for success or
* failure using U_SUCCESS() or U_FAILURE():
*
*     UErrorCode errorCode = U_ZERO_ERROR;
*     // call ICU API that needs an error code parameter.
*     if (U_FAILURE(errorCode)) {
*         // An error occurred. Handle it here.
*     }
*
* C++ code should use icu::ErrorCode, available in unicode/errorcode.h, or a
* suitable subclass.
*
* For more information, see:
* https://unicode-org.github.io/icu/userguide/dev/codingguidelines#details-about-icu-error-codes
*
* Note: By convention, ICU functions that take a reference (C++) or a pointer
* (C) to a UErrorCode first test:
*
*     if (U_FAILURE(errorCode)) { return immediately; }
*
* so that in a chain of such functions the first one that sets an error code
* causes the following ones to not perform any operations.
*
* @stable ICU 2.0
*/
UErrorCode :: enum s32 {
    USING_FALLBACK_WARNING           :: -128;

    ERROR_WARNING_START              :: -128;

    USING_DEFAULT_WARNING            :: -127;

    SAFECLONE_ALLOCATED_WARNING      :: -126;

    STATE_OLD_WARNING                :: -125;

    STRING_NOT_TERMINATED_WARNING    :: -124;

    SORT_KEY_TOO_SHORT_WARNING       :: -123;

    AMBIGUOUS_ALIAS_WARNING          :: -122;

    DIFFERENT_UCA_VERSION            :: -121;

    PLUGIN_CHANGED_LEVEL_WARNING     :: -120;

    ERROR_WARNING_LIMIT              :: -119;

    ZERO_ERROR                       :: 0;

    ILLEGAL_ARGUMENT_ERROR           :: 1;
    MISSING_RESOURCE_ERROR           :: 2;
    INVALID_FORMAT_ERROR             :: 3;
    FILE_ACCESS_ERROR                :: 4;
    INTERNAL_PROGRAM_ERROR           :: 5;
    MESSAGE_PARSE_ERROR              :: 6;
    MEMORY_ALLOCATION_ERROR          :: 7;
    INDEX_OUTOFBOUNDS_ERROR          :: 8;
    PARSE_ERROR                      :: 9;
    INVALID_CHAR_FOUND               :: 10;
    TRUNCATED_CHAR_FOUND             :: 11;
    ILLEGAL_CHAR_FOUND               :: 12;
    INVALID_TABLE_FORMAT             :: 13;
    INVALID_TABLE_FILE               :: 14;
    BUFFER_OVERFLOW_ERROR            :: 15;
    UNSUPPORTED_ERROR                :: 16;
    RESOURCE_TYPE_MISMATCH           :: 17;
    ILLEGAL_ESCAPE_SEQUENCE          :: 18;
    UNSUPPORTED_ESCAPE_SEQUENCE      :: 19;
    NO_SPACE_AVAILABLE               :: 20;
    CE_NOT_FOUND_ERROR               :: 21;
    PRIMARY_TOO_LONG_ERROR           :: 22;
    STATE_TOO_OLD_ERROR              :: 23;
    TOO_MANY_ALIASES_ERROR           :: 24;

    ENUM_OUT_OF_SYNC_ERROR           :: 25;
    INVARIANT_CONVERSION_ERROR       :: 26;
    INVALID_STATE_ERROR              :: 27;
    COLLATOR_VERSION_MISMATCH        :: 28;
    USELESS_COLLATOR_ERROR           :: 29;
    NO_WRITE_PERMISSION              :: 30;

    INPUT_TOO_LONG_ERROR             :: 31;

    STANDARD_ERROR_LIMIT             :: 32;

    BAD_VARIABLE_DEFINITION          :: 65536;
    PARSE_ERROR_START                :: 65536;
    MALFORMED_RULE                   :: 65537;
    MALFORMED_SET                    :: 65538;
    MALFORMED_SYMBOL_REFERENCE       :: 65539;
    MALFORMED_UNICODE_ESCAPE         :: 65540;
    MALFORMED_VARIABLE_DEFINITION    :: 65541;
    MALFORMED_VARIABLE_REFERENCE     :: 65542;
    MISMATCHED_SEGMENT_DELIMITERS    :: 65543;
    MISPLACED_ANCHOR_START           :: 65544;
    MISPLACED_CURSOR_OFFSET          :: 65545;
    MISPLACED_QUANTIFIER             :: 65546;
    MISSING_OPERATOR                 :: 65547;
    MISSING_SEGMENT_CLOSE            :: 65548;
    MULTIPLE_ANTE_CONTEXTS           :: 65549;
    MULTIPLE_CURSORS                 :: 65550;
    MULTIPLE_POST_CONTEXTS           :: 65551;
    TRAILING_BACKSLASH               :: 65552;
    UNDEFINED_SEGMENT_REFERENCE      :: 65553;
    UNDEFINED_VARIABLE               :: 65554;
    UNQUOTED_SPECIAL                 :: 65555;
    UNTERMINATED_QUOTE               :: 65556;
    RULE_MASK_ERROR                  :: 65557;
    MISPLACED_COMPOUND_FILTER        :: 65558;
    MULTIPLE_COMPOUND_FILTERS        :: 65559;
    INVALID_RBT_SYNTAX               :: 65560;
    INVALID_PROPERTY_PATTERN         :: 65561;
    MALFORMED_PRAGMA                 :: 65562;
    UNCLOSED_SEGMENT                 :: 65563;
    ILLEGAL_CHAR_IN_SEGMENT          :: 65564;
    VARIABLE_RANGE_EXHAUSTED         :: 65565;
    VARIABLE_RANGE_OVERLAP           :: 65566;
    ILLEGAL_CHARACTER                :: 65567;
    INTERNAL_TRANSLITERATOR_ERROR    :: 65568;
    INVALID_ID                       :: 65569;
    INVALID_FUNCTION                 :: 65570;

    PARSE_ERROR_LIMIT                :: 65571;

    UNEXPECTED_TOKEN                 :: 65792;
    FMT_PARSE_ERROR_START            :: 65792;
    MULTIPLE_DECIMAL_SEPARATORS      :: 65793;
    MULTIPLE_DECIMAL_SEPERATORS      :: 65793;
    MULTIPLE_EXPONENTIAL_SYMBOLS     :: 65794;
    MALFORMED_EXPONENTIAL_PATTERN    :: 65795;
    MULTIPLE_PERCENT_SYMBOLS         :: 65796;
    MULTIPLE_PERMILL_SYMBOLS         :: 65797;
    MULTIPLE_PAD_SPECIFIERS          :: 65798;
    PATTERN_SYNTAX_ERROR             :: 65799;
    ILLEGAL_PAD_POSITION             :: 65800;
    UNMATCHED_BRACES                 :: 65801;
    UNSUPPORTED_PROPERTY             :: 65802;
    UNSUPPORTED_ATTRIBUTE            :: 65803;
    ARGUMENT_TYPE_MISMATCH           :: 65804;
    DUPLICATE_KEYWORD                :: 65805;
    UNDEFINED_KEYWORD                :: 65806;
    DEFAULT_KEYWORD_MISSING          :: 65807;
    DECIMAL_NUMBER_SYNTAX_ERROR      :: 65808;
    FORMAT_INEXACT_ERROR             :: 65809;
    NUMBER_ARG_OUTOFBOUNDS_ERROR     :: 65810;
    NUMBER_SKELETON_SYNTAX_ERROR     :: 65811;

    FMT_PARSE_ERROR_LIMIT            :: 65812;

    BRK_INTERNAL_ERROR               :: 66048;
    BRK_ERROR_START                  :: 66048;
    BRK_HEX_DIGITS_EXPECTED          :: 66049;
    BRK_SEMICOLON_EXPECTED           :: 66050;
    BRK_RULE_SYNTAX                  :: 66051;
    BRK_UNCLOSED_SET                 :: 66052;
    BRK_ASSIGN_ERROR                 :: 66053;
    BRK_VARIABLE_REDFINITION         :: 66054;
    BRK_MISMATCHED_PAREN             :: 66055;
    BRK_NEW_LINE_IN_QUOTED_STRING    :: 66056;
    BRK_UNDEFINED_VARIABLE           :: 66057;
    BRK_INIT_ERROR                   :: 66058;
    BRK_RULE_EMPTY_SET               :: 66059;
    BRK_UNRECOGNIZED_OPTION          :: 66060;
    BRK_MALFORMED_RULE_TAG           :: 66061;

    BRK_ERROR_LIMIT                  :: 66062;

    REGEX_INTERNAL_ERROR             :: 66304;
    REGEX_ERROR_START                :: 66304;
    REGEX_RULE_SYNTAX                :: 66305;
    REGEX_INVALID_STATE              :: 66306;
    REGEX_BAD_ESCAPE_SEQUENCE        :: 66307;
    REGEX_PROPERTY_SYNTAX            :: 66308;
    REGEX_UNIMPLEMENTED              :: 66309;
    REGEX_MISMATCHED_PAREN           :: 66310;
    REGEX_NUMBER_TOO_BIG             :: 66311;
    REGEX_BAD_INTERVAL               :: 66312;
    REGEX_MAX_LT_MIN                 :: 66313;
    REGEX_INVALID_BACK_REF           :: 66314;
    REGEX_INVALID_FLAG               :: 66315;
    REGEX_LOOK_BEHIND_LIMIT          :: 66316;
    REGEX_SET_CONTAINS_STRING        :: 66317;

    REGEX_OCTAL_TOO_BIG              :: 66318;

    REGEX_MISSING_CLOSE_BRACKET      :: 66319;
    REGEX_INVALID_RANGE              :: 66320;
    REGEX_STACK_OVERFLOW             :: 66321;
    REGEX_TIME_OUT                   :: 66322;
    REGEX_STOPPED_BY_CALLER          :: 66323;
    REGEX_PATTERN_TOO_BIG            :: 66324;
    REGEX_INVALID_CAPTURE_GROUP_NAME :: 66325;

    REGEX_ERROR_LIMIT                :: 66326;

    IDNA_PROHIBITED_ERROR            :: 66560;
    IDNA_ERROR_START                 :: 66560;
    IDNA_UNASSIGNED_ERROR            :: 66561;
    IDNA_CHECK_BIDI_ERROR            :: 66562;
    IDNA_STD3_ASCII_RULES_ERROR      :: 66563;
    IDNA_ACE_PREFIX_ERROR            :: 66564;
    IDNA_VERIFICATION_ERROR          :: 66565;
    IDNA_LABEL_TOO_LONG_ERROR        :: 66566;
    IDNA_ZERO_LENGTH_LABEL_ERROR     :: 66567;
    IDNA_DOMAIN_NAME_TOO_LONG_ERROR  :: 66568;

    IDNA_ERROR_LIMIT                 :: 66569;

    STRINGPREP_PROHIBITED_ERROR      :: 66560;
    STRINGPREP_UNASSIGNED_ERROR      :: 66561;
    STRINGPREP_CHECK_BIDI_ERROR      :: 66562;

    PLUGIN_ERROR_START               :: 66816;
    PLUGIN_TOO_HIGH                  :: 66816;
    PLUGIN_DIDNT_SET_LEVEL           :: 66817;

    PLUGIN_ERROR_LIMIT               :: 66818;

    ERROR_LIMIT                      :: 66818;
}

u_errorName :: (code: UErrorCode) -> *u8 #foreign libicutu "u_errorName_73";

/**
* An enumeration object.
* For usage in C programs.
* @stable ICU 2.2
*/
UEnumeration :: struct {}

uenum_close :: (en: *UEnumeration) -> void #foreign libicutu "uenum_close_73";

uenum_count :: (en: *UEnumeration, status: *UErrorCode) -> s32 #foreign libicutu "uenum_count_73";

uenum_unext :: (en: *UEnumeration, resultLength: *s32, status: *UErrorCode) -> *UChar #foreign libicutu "uenum_unext_73";

uenum_next :: (en: *UEnumeration, resultLength: *s32, status: *UErrorCode) -> *u8 #foreign libicutu "uenum_next_73";

uenum_reset :: (en: *UEnumeration, status: *UErrorCode) -> void #foreign libicutu "uenum_reset_73";

uenum_openUCharStringsEnumeration :: (strings: **UChar, count: s32, ec: *UErrorCode) -> *UEnumeration #foreign libicutu "uenum_openUCharStringsEnumeration_73";

uenum_openCharStringsEnumeration :: (strings: **u8, count: s32, ec: *UErrorCode) -> *UEnumeration #foreign libicutu "uenum_openCharStringsEnumeration_73";

/**
* Constants for *_getLocale()
* Allow user to select whether she wants information on
* requested, valid or actual locale.
* For example, a collator for "en_US_CALIFORNIA" was
* requested. In the current state of ICU (2.0),
* the requested locale is "en_US_CALIFORNIA",
* the valid locale is "en_US" (most specific locale supported by ICU)
* and the actual locale is "root" (the collation data comes unmodified
* from the UCA)
* The locale is considered supported by ICU if there is a core ICU bundle
* for that locale (although it may be empty).
* @stable ICU 2.1
*/
ULocDataLocaleType :: enum u32 {
    ACTUAL_LOCALE          :: 0;

    VALID_LOCALE           :: 1;

    REQUESTED_LOCALE       :: 2;

    DATA_LOCALE_TYPE_LIMIT :: 3;
}

uloc_getDefault :: () -> *u8 #foreign libicutu "uloc_getDefault_73";

uloc_setDefault :: (localeID: *u8, status: *UErrorCode) -> void #foreign libicutu "uloc_setDefault_73";

uloc_getLanguage :: (localeID: *u8, language: *u8, languageCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getLanguage_73";

uloc_getScript :: (localeID: *u8, script: *u8, scriptCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getScript_73";

uloc_getCountry :: (localeID: *u8, country: *u8, countryCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getCountry_73";

uloc_getVariant :: (localeID: *u8, variant: *u8, variantCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getVariant_73";

uloc_getName :: (localeID: *u8, name: *u8, nameCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getName_73";

uloc_canonicalize :: (localeID: *u8, name: *u8, nameCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_canonicalize_73";

uloc_getISO3Language :: (localeID: *u8) -> *u8 #foreign libicutu "uloc_getISO3Language_73";

uloc_getISO3Country :: (localeID: *u8) -> *u8 #foreign libicutu "uloc_getISO3Country_73";

uloc_getLCID :: (localeID: *u8) -> u32 #foreign libicutu "uloc_getLCID_73";

uloc_getDisplayLanguage :: (locale: *u8, displayLocale: *u8, language: *UChar, languageCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayLanguage_73";

uloc_getDisplayScript :: (locale: *u8, displayLocale: *u8, script: *UChar, scriptCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayScript_73";

uloc_getDisplayCountry :: (locale: *u8, displayLocale: *u8, country: *UChar, countryCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayCountry_73";

uloc_getDisplayVariant :: (locale: *u8, displayLocale: *u8, variant: *UChar, variantCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayVariant_73";

uloc_getDisplayKeyword :: (keyword: *u8, displayLocale: *u8, dest: *UChar, destCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayKeyword_73";

uloc_getDisplayKeywordValue :: (locale: *u8, keyword: *u8, displayLocale: *u8, dest: *UChar, destCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayKeywordValue_73";

uloc_getDisplayName :: (localeID: *u8, inLocaleID: *u8, result: *UChar, maxResultSize: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getDisplayName_73";

uloc_getAvailable :: (n: s32) -> *u8 #foreign libicutu "uloc_getAvailable_73";

uloc_countAvailable :: () -> s32 #foreign libicutu "uloc_countAvailable_73";

/**
* Types for uloc_getAvailableByType and uloc_countAvailableByType.
*
* @stable ICU 65
*/
ULocAvailableType :: enum u32 {
    DEFAULT             :: 0;

    ONLY_LEGACY_ALIASES :: 1;

    WITH_LEGACY_ALIASES :: 2;

    COUNT               :: 3;
}

uloc_openAvailableByType :: (type: ULocAvailableType, status: *UErrorCode) -> *UEnumeration #foreign libicutu "uloc_openAvailableByType_73";

uloc_getISOLanguages :: () -> **u8 #foreign libicutu "uloc_getISOLanguages_73";

uloc_getISOCountries :: () -> **u8 #foreign libicutu "uloc_getISOCountries_73";

uloc_getParent :: (localeID: *u8, parent: *u8, parentCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getParent_73";

uloc_getBaseName :: (localeID: *u8, name: *u8, nameCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_getBaseName_73";

uloc_openKeywords :: (localeID: *u8, status: *UErrorCode) -> *UEnumeration #foreign libicutu "uloc_openKeywords_73";

uloc_getKeywordValue :: (localeID: *u8, keywordName: *u8, buffer: *u8, bufferCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getKeywordValue_73";

uloc_setKeywordValue :: (keywordName: *u8, keywordValue: *u8, buffer: *u8, bufferCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_setKeywordValue_73";

uloc_isRightToLeft :: (locale: *u8) -> UBool #foreign libicutu "uloc_isRightToLeft_73";

/**
* enums for the  return value for the character and line orientation
* functions.
* @stable ICU 4.0
*/
ULayoutType :: enum u32 {
    LTR     :: 0;
    RTL     :: 1;
    TTB     :: 2;
    BTT     :: 3;
    UNKNOWN :: 4;
}

uloc_getCharacterOrientation :: (localeId: *u8, status: *UErrorCode) -> ULayoutType #foreign libicutu "uloc_getCharacterOrientation_73";

uloc_getLineOrientation :: (localeId: *u8, status: *UErrorCode) -> ULayoutType #foreign libicutu "uloc_getLineOrientation_73";

/**
* Output values which uloc_acceptLanguage() writes to the 'outResult' parameter.
*
* @see uloc_acceptLanguageFromHTTP
* @see uloc_acceptLanguage
* @stable ICU 3.2
*/
UAcceptResult :: enum u32 {
    FAILED   :: 0;

    VALID    :: 1;

    FALLBACK :: 2;
}

uloc_acceptLanguageFromHTTP :: (result: *u8, resultAvailable: s32, outResult: *UAcceptResult, httpAcceptLanguage: *u8, availableLocales: *UEnumeration, status: *UErrorCode) -> s32 #foreign libicutu "uloc_acceptLanguageFromHTTP_73";

uloc_acceptLanguage :: (result: *u8, resultAvailable: s32, outResult: *UAcceptResult, acceptList: **u8, acceptListCount: s32, availableLocales: *UEnumeration, status: *UErrorCode) -> s32 #foreign libicutu "uloc_acceptLanguage_73";

uloc_getLocaleForLCID :: (hostID: u32, locale: *u8, localeCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "uloc_getLocaleForLCID_73";

uloc_addLikelySubtags :: (localeID: *u8, maximizedLocaleID: *u8, maximizedLocaleIDCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_addLikelySubtags_73";

uloc_minimizeSubtags :: (localeID: *u8, minimizedLocaleID: *u8, minimizedLocaleIDCapacity: s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_minimizeSubtags_73";

uloc_forLanguageTag :: (langtag: *u8, localeID: *u8, localeIDCapacity: s32, parsedLength: *s32, err: *UErrorCode) -> s32 #foreign libicutu "uloc_forLanguageTag_73";

uloc_toLanguageTag :: (localeID: *u8, langtag: *u8, langtagCapacity: s32, strict: UBool, err: *UErrorCode) -> s32 #foreign libicutu "uloc_toLanguageTag_73";

uloc_toUnicodeLocaleKey :: (keyword: *u8) -> *u8 #foreign libicutu "uloc_toUnicodeLocaleKey_73";

uloc_toUnicodeLocaleType :: (keyword: *u8, value: *u8) -> *u8 #foreign libicutu "uloc_toUnicodeLocaleType_73";

uloc_toLegacyKey :: (keyword: *u8) -> *u8 #foreign libicutu "uloc_toLegacyKey_73";

uloc_toLegacyType :: (keyword: *u8, value: *u8) -> *u8 #foreign libicutu "uloc_toLegacyType_73";

/** A calendar.
*  For usage in C programs.
* @stable ICU 2.0
*/
UCalendar :: *void;

/** Possible types of UCalendars
* @stable ICU 2.0
*/
UCalendarType :: enum u32 {
    TRADITIONAL :: 0;

    DEFAULT     :: 0;

    GREGORIAN   :: 1;
}

/** Possible fields in a UCalendar
* @stable ICU 2.0
*/
UCalendarDateFields :: enum u32 {
    ERA                  :: 0;

    YEAR                 :: 1;

    MONTH                :: 2;

    WEEK_OF_YEAR         :: 3;

    WEEK_OF_MONTH        :: 4;

    DATE                 :: 5;

    DAY_OF_YEAR          :: 6;

    DAY_OF_WEEK          :: 7;

    DAY_OF_WEEK_IN_MONTH :: 8;

    AM_PM                :: 9;

    HOUR                 :: 10;

    HOUR_OF_DAY          :: 11;

    MINUTE               :: 12;

    SECOND               :: 13;

    MILLISECOND          :: 14;

    ZONE_OFFSET          :: 15;

    DST_OFFSET           :: 16;

    YEAR_WOY             :: 17;

    DOW_LOCAL            :: 18;

    EXTENDED_YEAR        :: 19;

    JULIAN_DAY           :: 20;

    MILLISECONDS_IN_DAY  :: 21;

    IS_LEAP_MONTH        :: 22;

    ORDINAL_MONTH        :: 23;

    FIELD_COUNT          :: 24;

    DAY_OF_MONTH         :: 5;
}

/**
* Useful constant for days of week. Note: Calendar day-of-week is 1-based. Clients
* who create locale resources for the field of first-day-of-week should be aware of
* this. For instance, in US locale, first-day-of-week is set to 1, i.e., UCAL_SUNDAY.
*/
/** Possible days of the week in a UCalendar
* @stable ICU 2.0
*/
UCalendarDaysOfWeek :: enum u32 {
    SUNDAY    :: 1;

    MONDAY    :: 2;

    TUESDAY   :: 3;

    WEDNESDAY :: 4;

    THURSDAY  :: 5;

    FRIDAY    :: 6;

    SATURDAY  :: 7;
}

/** Possible months in a UCalendar. Note: Calendar month is 0-based.
* @stable ICU 2.0
*/
UCalendarMonths :: enum u32 {
    JANUARY    :: 0;

    FEBRUARY   :: 1;

    MARCH      :: 2;

    APRIL      :: 3;

    MAY        :: 4;

    JUNE       :: 5;

    JULY       :: 6;

    AUGUST     :: 7;

    SEPTEMBER  :: 8;

    OCTOBER    :: 9;

    NOVEMBER   :: 10;

    DECEMBER   :: 11;

    UNDECIMBER :: 12;
}

/** Possible AM/PM values in a UCalendar
* @stable ICU 2.0
*/
UCalendarAMPMs :: enum u32 {
    AM :: 0;

    PM :: 1;
}

/**
* System time zone type constants used by filtering zones
* in ucal_openTimeZoneIDEnumeration.
* @see ucal_openTimeZoneIDEnumeration
* @stable ICU 4.8
*/
USystemTimeZoneType :: enum u32 {
    ANY                :: 0;

    CANONICAL          :: 1;

    CANONICAL_LOCATION :: 2;
}

ucal_openTimeZoneIDEnumeration :: (zoneType: USystemTimeZoneType, region: *u8, rawOffset: *s32, ec: *UErrorCode) -> *UEnumeration #foreign libicutu "ucal_openTimeZoneIDEnumeration_73";

ucal_openTimeZones :: (ec: *UErrorCode) -> *UEnumeration #foreign libicutu "ucal_openTimeZones_73";

ucal_openCountryTimeZones :: (country: *u8, ec: *UErrorCode) -> *UEnumeration #foreign libicutu "ucal_openCountryTimeZones_73";

ucal_getDefaultTimeZone :: (result: *UChar, resultCapacity: s32, ec: *UErrorCode) -> s32 #foreign libicutu "ucal_getDefaultTimeZone_73";

ucal_setDefaultTimeZone :: (zoneID: *UChar, ec: *UErrorCode) -> void #foreign libicutu "ucal_setDefaultTimeZone_73";

ucal_getHostTimeZone :: (result: *UChar, resultCapacity: s32, ec: *UErrorCode) -> s32 #foreign libicutu "ucal_getHostTimeZone_73";

ucal_getDSTSavings :: (zoneID: *UChar, ec: *UErrorCode) -> s32 #foreign libicutu "ucal_getDSTSavings_73";

ucal_getNow :: () -> UDate #foreign libicutu "ucal_getNow_73";

ucal_open :: (zoneID: *UChar, len: s32, locale: *u8, type: UCalendarType, status: *UErrorCode) -> *UCalendar #foreign libicutu "ucal_open_73";

ucal_close :: (cal: *UCalendar) -> void #foreign libicutu "ucal_close_73";

ucal_clone :: (cal: *UCalendar, status: *UErrorCode) -> *UCalendar #foreign libicutu "ucal_clone_73";

ucal_setTimeZone :: (cal: *UCalendar, zoneID: *UChar, len: s32, status: *UErrorCode) -> void #foreign libicutu "ucal_setTimeZone_73";

ucal_getTimeZoneID :: (cal: *UCalendar, result: *UChar, resultLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getTimeZoneID_73";

/**
* Possible formats for a UCalendar's display name
* @stable ICU 2.0
*/
UCalendarDisplayNameType :: enum u32 {
    STANDARD       :: 0;

    SHORT_STANDARD :: 1;

    DST            :: 2;

    SHORT_DST      :: 3;
}

ucal_getTimeZoneDisplayName :: (cal: *UCalendar, type: UCalendarDisplayNameType, locale: *u8, result: *UChar, resultLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getTimeZoneDisplayName_73";

ucal_inDaylightTime :: (cal: *UCalendar, status: *UErrorCode) -> UBool #foreign libicutu "ucal_inDaylightTime_73";

ucal_setGregorianChange :: (cal: *UCalendar, date: UDate, pErrorCode: *UErrorCode) -> void #foreign libicutu "ucal_setGregorianChange_73";

ucal_getGregorianChange :: (cal: *UCalendar, pErrorCode: *UErrorCode) -> UDate #foreign libicutu "ucal_getGregorianChange_73";

/**
* Types of UCalendar attributes
* @stable ICU 2.0
*/
UCalendarAttribute :: enum u32 {
    LENIENT                    :: 0;

    FIRST_DAY_OF_WEEK          :: 1;

    MINIMAL_DAYS_IN_FIRST_WEEK :: 2;

    REPEATED_WALL_TIME         :: 3;

    SKIPPED_WALL_TIME          :: 4;
}

/**
* Options for handling ambiguous wall time at time zone
* offset transitions.
* @stable ICU 49
*/
UCalendarWallTimeOption :: enum u32 {
    LAST       :: 0;

    FIRST      :: 1;

    NEXT_VALID :: 2;
}

ucal_getAttribute :: (cal: *UCalendar, attr: UCalendarAttribute) -> s32 #foreign libicutu "ucal_getAttribute_73";

ucal_setAttribute :: (cal: *UCalendar, attr: UCalendarAttribute, newValue: s32) -> void #foreign libicutu "ucal_setAttribute_73";

ucal_getAvailable :: (localeIndex: s32) -> *u8 #foreign libicutu "ucal_getAvailable_73";

ucal_countAvailable :: () -> s32 #foreign libicutu "ucal_countAvailable_73";

ucal_getMillis :: (cal: *UCalendar, status: *UErrorCode) -> UDate #foreign libicutu "ucal_getMillis_73";

ucal_setMillis :: (cal: *UCalendar, dateTime: UDate, status: *UErrorCode) -> void #foreign libicutu "ucal_setMillis_73";

ucal_setDate :: (cal: *UCalendar, year: s32, month: s32, date: s32, status: *UErrorCode) -> void #foreign libicutu "ucal_setDate_73";

ucal_setDateTime :: (cal: *UCalendar, year: s32, month: s32, date: s32, hour: s32, minute: s32, second: s32, status: *UErrorCode) -> void #foreign libicutu "ucal_setDateTime_73";

ucal_equivalentTo :: (cal1: *UCalendar, cal2: *UCalendar) -> UBool #foreign libicutu "ucal_equivalentTo_73";

ucal_add :: (cal: *UCalendar, field: UCalendarDateFields, amount: s32, status: *UErrorCode) -> void #foreign libicutu "ucal_add_73";

ucal_roll :: (cal: *UCalendar, field: UCalendarDateFields, amount: s32, status: *UErrorCode) -> void #foreign libicutu "ucal_roll_73";

ucal_get :: (cal: *UCalendar, field: UCalendarDateFields, status: *UErrorCode) -> s32 #foreign libicutu "ucal_get_73";

ucal_set :: (cal: *UCalendar, field: UCalendarDateFields, value: s32) -> void #foreign libicutu "ucal_set_73";

ucal_isSet :: (cal: *UCalendar, field: UCalendarDateFields) -> UBool #foreign libicutu "ucal_isSet_73";

ucal_clearField :: (cal: *UCalendar, field: UCalendarDateFields) -> void #foreign libicutu "ucal_clearField_73";

ucal_clear :: (calendar: *UCalendar) -> void #foreign libicutu "ucal_clear_73";

/**
* Possible limit values for a UCalendar
* @stable ICU 2.0
*/
UCalendarLimitType :: enum u32 {
    MINIMUM          :: 0;

    MAXIMUM          :: 1;

    GREATEST_MINIMUM :: 2;

    LEAST_MAXIMUM    :: 3;

    ACTUAL_MINIMUM   :: 4;

    ACTUAL_MAXIMUM   :: 5;
}

ucal_getLimit :: (cal: *UCalendar, field: UCalendarDateFields, type: UCalendarLimitType, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getLimit_73";

ucal_getLocaleByType :: (cal: *UCalendar, type: ULocDataLocaleType, status: *UErrorCode) -> *u8 #foreign libicutu "ucal_getLocaleByType_73";

ucal_getTZDataVersion :: (status: *UErrorCode) -> *u8 #foreign libicutu "ucal_getTZDataVersion_73";

ucal_getCanonicalTimeZoneID :: (id: *UChar, len: s32, result: *UChar, resultCapacity: s32, isSystemID: *UBool, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getCanonicalTimeZoneID_73";

ucal_getType :: (cal: *UCalendar, status: *UErrorCode) -> *u8 #foreign libicutu "ucal_getType_73";

ucal_getKeywordValuesForLocale :: (key: *u8, locale: *u8, commonlyUsed: UBool, status: *UErrorCode) -> *UEnumeration #foreign libicutu "ucal_getKeywordValuesForLocale_73";

/** Weekday types, as returned by ucal_getDayOfWeekType().
* @stable ICU 4.4
*/
UCalendarWeekdayType :: enum u32 {
    WEEKDAY       :: 0;

    WEEKEND       :: 1;

    WEEKEND_ONSET :: 2;

    WEEKEND_CEASE :: 3;
}

ucal_getDayOfWeekType :: (cal: *UCalendar, dayOfWeek: UCalendarDaysOfWeek, status: *UErrorCode) -> UCalendarWeekdayType #foreign libicutu "ucal_getDayOfWeekType_73";

ucal_getWeekendTransition :: (cal: *UCalendar, dayOfWeek: UCalendarDaysOfWeek, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getWeekendTransition_73";

ucal_isWeekend :: (cal: *UCalendar, date: UDate, status: *UErrorCode) -> UBool #foreign libicutu "ucal_isWeekend_73";

ucal_getFieldDifference :: (cal: *UCalendar, target: UDate, field: UCalendarDateFields, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getFieldDifference_73";

/**
* Time zone transition types for ucal_getTimeZoneTransitionDate
* @stable ICU 50
*/
UTimeZoneTransitionType :: enum u32 {
    NEXT               :: 0;

    NEXT_INCLUSIVE     :: 1;

    PREVIOUS           :: 2;

    PREVIOUS_INCLUSIVE :: 3;
}

ucal_getTimeZoneTransitionDate :: (cal: *UCalendar, type: UTimeZoneTransitionType, transition: *UDate, status: *UErrorCode) -> UBool #foreign libicutu "ucal_getTimeZoneTransitionDate_73";

ucal_getWindowsTimeZoneID :: (id: *UChar, len: s32, winid: *UChar, winidCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getWindowsTimeZoneID_73";

ucal_getTimeZoneIDForWindowsID :: (winid: *UChar, len: s32, region: *u8, id: *UChar, idCapacity: s32, status: *UErrorCode) -> s32 #foreign libicutu "ucal_getTimeZoneIDForWindowsID_73";

/**
* Options used by ucal_getTimeZoneOffsetFromLocal and BasicTimeZone::getOffsetFromLocal()
* to specify how to interpret an input time when it does not exist, or when it is ambiguous,
* around a time zone transition.
* @stable ICU 69
*/
UTimeZoneLocalOption :: enum u32 {
    FORMER          :: 4;

    LATTER          :: 12;

    STANDARD_FORMER :: 5;

    STANDARD_LATTER :: 13;

    DAYLIGHT_FORMER :: 7;

    DAYLIGHT_LATTER :: 15;
}

ucal_getTimeZoneOffsetFromLocal :: (cal: *UCalendar, nonExistingTimeOpt: UTimeZoneLocalOption, duplicatedTimeOpt: UTimeZoneLocalOption, rawOffset: *s32, dstOffset: *s32, status: *UErrorCode) -> void #foreign libicutu "ucal_getTimeZoneOffsetFromLocal_73";

/**
* Currency Usage used for Decimal Format
* @stable ICU 54
*/
UCurrencyUsage :: enum u32 {
    STANDARD :: 0;

    CASH     :: 1;

    COUNT    :: 2;
}

ucurr_forLocale :: (locale: *u8, buff: *UChar, buffCapacity: s32, ec: *UErrorCode) -> s32 #foreign libicutu "ucurr_forLocale_73";

/**
* Selector constants for ucurr_getName().
*
* @see ucurr_getName
* @stable ICU 2.6
*/
UCurrNameStyle :: enum u32 {
    SYMBOL_NAME         :: 0;

    LONG_NAME           :: 1;

    NARROW_SYMBOL_NAME  :: 2;

    FORMAL_SYMBOL_NAME  :: 3;

    VARIANT_SYMBOL_NAME :: 4;
}

/**
* @stable ICU 2.6
*/
UCurrRegistryKey :: *void;

ucurr_register :: (isoCode: *UChar, locale: *u8, status: *UErrorCode) -> UCurrRegistryKey #foreign libicutu "ucurr_register_73";

ucurr_unregister :: (key: UCurrRegistryKey, status: *UErrorCode) -> UBool #foreign libicutu "ucurr_unregister_73";

ucurr_getName :: (currency: *UChar, locale: *u8, nameStyle: UCurrNameStyle, isChoiceFormat: *UBool, len: *s32, ec: *UErrorCode) -> *UChar #foreign libicutu "ucurr_getName_73";

ucurr_getPluralName :: (currency: *UChar, locale: *u8, isChoiceFormat: *UBool, pluralCount: *u8, len: *s32, ec: *UErrorCode) -> *UChar #foreign libicutu "ucurr_getPluralName_73";

ucurr_getDefaultFractionDigits :: (currency: *UChar, ec: *UErrorCode) -> s32 #foreign libicutu "ucurr_getDefaultFractionDigits_73";

ucurr_getDefaultFractionDigitsForUsage :: (currency: *UChar, usage: UCurrencyUsage, ec: *UErrorCode) -> s32 #foreign libicutu "ucurr_getDefaultFractionDigitsForUsage_73";

ucurr_getRoundingIncrement :: (currency: *UChar, ec: *UErrorCode) -> float64 #foreign libicutu "ucurr_getRoundingIncrement_73";

ucurr_getRoundingIncrementForUsage :: (currency: *UChar, usage: UCurrencyUsage, ec: *UErrorCode) -> float64 #foreign libicutu "ucurr_getRoundingIncrementForUsage_73";

/**
* Selector constants for ucurr_openCurrencies().
*
* @see ucurr_openCurrencies
* @stable ICU 3.2
*/
UCurrCurrencyType :: enum u32 {
    ALL            :: 2147483647;

    COMMON         :: 1;

    UNCOMMON       :: 2;

    DEPRECATED     :: 4;

    NON_DEPRECATED :: 8;
}

ucurr_openISOCurrencies :: (currType: u32, pErrorCode: *UErrorCode) -> *UEnumeration #foreign libicutu "ucurr_openISOCurrencies_73";

ucurr_isAvailable :: (isoCode: *UChar, from: UDate, to: UDate, errorCode: *UErrorCode) -> UBool #foreign libicutu "ucurr_isAvailable_73";

ucurr_countCurrencies :: (locale: *u8, date: UDate, ec: *UErrorCode) -> s32 #foreign libicutu "ucurr_countCurrencies_73";

ucurr_forLocaleAndDate :: (locale: *u8, date: UDate, index: s32, buff: *UChar, buffCapacity: s32, ec: *UErrorCode) -> s32 #foreign libicutu "ucurr_forLocaleAndDate_73";

ucurr_getKeywordValuesForLocale :: (key: *u8, locale: *u8, commonlyUsed: UBool, status: *UErrorCode) -> *UEnumeration #foreign libicutu "ucurr_getKeywordValuesForLocale_73";

ucurr_getNumericCode :: (currency: *UChar) -> s32 #foreign libicutu "ucurr_getNumericCode_73";

/** A struct representing a range of text containing a specific field
*  @stable ICU 2.0
*/
UFieldPosition :: struct {
    /**
    * The field
    * @stable ICU 2.0
    */
    field:      s32;

    /**
    * The start of the text range containing field
    * @stable ICU 2.0
    */
    beginIndex: s32;

    /**
    * The limit of the text range containing field
    * @stable ICU 2.0
    */
    endIndex:   s32;
}

/**
* Opaque type returned by registerInstance, registerFactory and unregister for service registration.
* @stable ICU 2.6
*/
URegistryKey :: *void;

/**
* \file
* \brief C API: Parse Error Information
*/
/**
* The capacity of the context strings in UParseError.
* @stable ICU 2.0
*/
anon_enum :: enum u32 {
    U_PARSE_CONTEXT_LEN :: 16;
}

/**
* A UParseError struct is used to returned detailed information about
* parsing errors.  It is used by ICU parsing engines that parse long
* rules, patterns, or programs, where the text being parsed is long
* enough that more information than a UErrorCode is needed to
* localize the error.
*
* <p>The line, offset, and context fields are optional; parsing
* engines may choose not to use to use them.
*
* <p>The preContext and postContext strings include some part of the
* context surrounding the error.  If the source text is "let for=7"
* and "for" is the error (e.g., because it is a reserved word), then
* some examples of what a parser might produce are the following:
*
* <pre>
* preContext   postContext
* ""           ""            The parser does not support context
* "let "       "=7"          Pre- and post-context only
* "let "       "for=7"       Pre- and post-context and error text
* ""           "for"         Error text only
* </pre>
*
* <p>Examples of engines which use UParseError (or may use it in the
* future) are Transliterator, RuleBasedBreakIterator, and
* RegexPattern.
*
* @stable ICU 2.0
*/
UParseError :: struct {
    /**
    * The line on which the error occurred.  If the parser uses this
    * field, it sets it to the line number of the source text line on
    * which the error appears, which will be a value >= 1.  If the
    * parse does not support line numbers, the value will be <= 0.
    * @stable ICU 2.0
    */
    line:        s32;

    /**
    * The character offset to the error.  If the line field is >= 1,
    * then this is the offset from the start of the line.  Otherwise,
    * this is the offset from the start of the text.  If the parser
    * does not support this field, it will have a value < 0.
    * @stable ICU 2.0
    */
    offset:      s32;

    /**
    * Textual context before the error.  Null-terminated.  The empty
    * string if not supported by parser.
    * @stable ICU 2.0
    */
    preContext:  [16] UChar;

    /**
    * The error itself and/or textual context after the error.
    * Null-terminated.  The empty string if not supported by parser.
    * @stable ICU 2.0
    */
    postContext: [16] UChar;
}

/**
* Enum designating the type of a UFormattable instance.
* Practically, this indicates which of the getters would return without conversion
* or error.
* @see icu::Formattable::Type
* @stable ICU 52
*/
UFormattableType :: enum u32 {
    DATE   :: 0;
    DOUBLE :: 1;
    LONG   :: 2;
    STRING :: 3;
    ARRAY  :: 4;
    INT64  :: 5;
    OBJECT :: 6;

    COUNT  :: 7;
}

/**
* Opaque type representing various types of data which may be used for formatting
* and parsing operations.
* @see icu::Formattable
* @stable ICU 52
*/
UFormattable :: *void;

ufmt_open :: (status: *UErrorCode) -> *UFormattable #foreign libicutu "ufmt_open_73";

ufmt_close :: (fmt: *UFormattable) -> void #foreign libicutu "ufmt_close_73";

ufmt_getType :: (fmt: *UFormattable, status: *UErrorCode) -> UFormattableType #foreign libicutu "ufmt_getType_73";

ufmt_isNumeric :: (fmt: *UFormattable) -> UBool #foreign libicutu "ufmt_isNumeric_73";

ufmt_getDate :: (fmt: *UFormattable, status: *UErrorCode) -> UDate #foreign libicutu "ufmt_getDate_73";

ufmt_getDouble :: (fmt: *UFormattable, status: *UErrorCode) -> float64 #foreign libicutu "ufmt_getDouble_73";

ufmt_getLong :: (fmt: *UFormattable, status: *UErrorCode) -> s32 #foreign libicutu "ufmt_getLong_73";

ufmt_getInt64 :: (fmt: *UFormattable, status: *UErrorCode) -> s64 #foreign libicutu "ufmt_getInt64_73";

ufmt_getObject :: (fmt: *UFormattable, status: *UErrorCode) -> *void #foreign libicutu "ufmt_getObject_73";

ufmt_getUChars :: (fmt: *UFormattable, len: *s32, status: *UErrorCode) -> *UChar #foreign libicutu "ufmt_getUChars_73";

ufmt_getArrayLength :: (fmt: *UFormattable, status: *UErrorCode) -> s32 #foreign libicutu "ufmt_getArrayLength_73";

ufmt_getArrayItemByIndex :: (fmt: *UFormattable, n: s32, status: *UErrorCode) -> *UFormattable #foreign libicutu "ufmt_getArrayItemByIndex_73";

ufmt_getDecNumChars :: (fmt: *UFormattable, len: *s32, status: *UErrorCode) -> *u8 #foreign libicutu "ufmt_getDecNumChars_73";

/**
* Display context types, for getting values of a particular setting.
* Note, the specific numeric values are internal and may change.
* @stable ICU 51
*/
UDisplayContextType :: enum u32 {
    DIALECT_HANDLING    :: 0;

    CAPITALIZATION      :: 1;

    DISPLAY_LENGTH      :: 2;

    SUBSTITUTE_HANDLING :: 3;
}

/**
* Display context settings.
* Note, the specific numeric values are internal and may change.
* @stable ICU 51
*/
UDisplayContext :: enum u32 {
    STANDARD_NAMES                           :: 0;

    DIALECT_NAMES                            :: 1;

    CAPITALIZATION_NONE                      :: 256;

    CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE    :: 257;

    CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE :: 258;

    CAPITALIZATION_FOR_UI_LIST_OR_MENU       :: 259;

    CAPITALIZATION_FOR_STANDALONE            :: 260;

    LENGTH_FULL                              :: 512;

    LENGTH_SHORT                             :: 513;

    SUBSTITUTE                               :: 768;

    NO_SUBSTITUTE                            :: 769;
}

/**
* Opaque UFieldPositionIterator object for use in C.
* @stable ICU 55
*/
UFieldPositionIterator :: struct {}

ufieldpositer_open :: (status: *UErrorCode) -> *UFieldPositionIterator #foreign libicutu "ufieldpositer_open_73";

ufieldpositer_close :: (fpositer: *UFieldPositionIterator) -> void #foreign libicutu "ufieldpositer_close_73";

ufieldpositer_next :: (fpositer: *UFieldPositionIterator, beginIndex: *s32, endIndex: *s32) -> s32 #foreign libicutu "ufieldpositer_next_73";

/** The possible number format rounding modes.
*
* <p>
* For more detail on rounding modes, see:
* https://unicode-org.github.io/icu/userguide/format_parse/numbers/rounding-modes
*
* @stable ICU 2.0
*/
UNumberFormatRoundingMode :: enum u32 {
    ROUND_CEILING      :: 0;
    ROUND_FLOOR        :: 1;
    ROUND_DOWN         :: 2;
    ROUND_UP           :: 3;

    ROUND_HALFEVEN     :: 4;

    FOUND_HALFEVEN     :: 4;

    ROUND_HALFDOWN     :: 5;
    ROUND_HALFUP       :: 6;

    ROUND_UNNECESSARY  :: 7;

    ROUND_HALF_ODD     :: 8;

    ROUND_HALF_CEILING :: 9;

    ROUND_HALF_FLOOR   :: 10;
}

/**
* An enum declaring the strategy for when and how to display grouping separators (i.e., the
* separator, often a comma or period, after every 2-3 powers of ten). The choices are several
* pre-built strategies for different use cases that employ locale data whenever possible. Example
* outputs for 1234 and 1234567 in <em>en-IN</em>:
*
* <ul>
* <li>OFF: 1234 and 12345
* <li>MIN2: 1234 and 12,34,567
* <li>AUTO: 1,234 and 12,34,567
* <li>ON_ALIGNED: 1,234 and 12,34,567
* <li>THOUSANDS: 1,234 and 1,234,567
* </ul>
*
* <p>
* The default is AUTO, which displays grouping separators unless the locale data says that grouping
* is not customary. To force grouping for all numbers greater than 1000 consistently across locales,
* use ON_ALIGNED. On the other hand, to display grouping less frequently than the default, use MIN2
* or OFF. See the docs of each option for details.
*
* <p>
* Note: This enum specifies the strategy for grouping sizes. To set which character to use as the
* grouping separator, use the "symbols" setter.
*
* @stable ICU 63
*/
UNumberGroupingStrategy :: enum u32 {
    OFF        :: 0;

    MIN2       :: 1;

    AUTO       :: 2;

    ON_ALIGNED :: 3;

    THOUSANDS  :: 4;

    COUNT      :: 5;
}

/** A number formatter.
*  For usage in C programs.
*  @stable ICU 2.0
*/
UNumberFormat :: *void;

/** The possible number format styles.
*  @stable ICU 2.0
*/
UNumberFormatStyle :: enum u32 {
    PATTERN_DECIMAL       :: 0;

    DECIMAL               :: 1;

    CURRENCY              :: 2;

    PERCENT               :: 3;

    SCIENTIFIC            :: 4;

    SPELLOUT              :: 5;

    ORDINAL               :: 6;

    DURATION              :: 7;

    NUMBERING_SYSTEM      :: 8;

    PATTERN_RULEBASED     :: 9;

    CURRENCY_ISO          :: 10;

    CURRENCY_PLURAL       :: 11;

    CURRENCY_ACCOUNTING   :: 12;

    CASH_CURRENCY         :: 13;

    DECIMAL_COMPACT_SHORT :: 14;

    DECIMAL_COMPACT_LONG  :: 15;

    CURRENCY_STANDARD     :: 16;

    FORMAT_STYLE_COUNT    :: 17;

    DEFAULT               :: 1;

    IGNORE                :: 0;
}

/** The possible number format pad positions.
*  @stable ICU 2.0
*/
UNumberFormatPadPosition :: enum u32 {
    BEFORE_PREFIX :: 0;
    AFTER_PREFIX  :: 1;
    BEFORE_SUFFIX :: 2;
    AFTER_SUFFIX  :: 3;
}

/**
* Constants for specifying short or long format.
* @stable ICU 51
*/
UNumberCompactStyle :: enum u32 {
    SHORT :: 0;

    LONG  :: 1;
}

/**
* Constants for specifying currency spacing
* @stable ICU 4.8
*/
UCurrencySpacing :: enum u32 {
    MATCH             :: 0;

    SURROUNDING_MATCH :: 1;

    INSERT            :: 2;

    SPACING_COUNT     :: 3;
}

/**
* FieldPosition and UFieldPosition selectors for format fields
* defined by NumberFormat and UNumberFormat.
* @stable ICU 49
*/
UNumberFormatFields :: enum u32 {
    INTEGER_FIELD            :: 0;

    FRACTION_FIELD           :: 1;

    DECIMAL_SEPARATOR_FIELD  :: 2;

    EXPONENT_SYMBOL_FIELD    :: 3;

    EXPONENT_SIGN_FIELD      :: 4;

    EXPONENT_FIELD           :: 5;

    GROUPING_SEPARATOR_FIELD :: 6;

    CURRENCY_FIELD           :: 7;

    PERCENT_FIELD            :: 8;

    PERMILL_FIELD            :: 9;

    SIGN_FIELD               :: 10;

    MEASURE_UNIT_FIELD       :: 11;

    COMPACT_FIELD            :: 12;

    APPROXIMATELY_SIGN_FIELD :: 13;

    FIELD_COUNT              :: 14;
}

/**
* Selectors with special numeric values to use locale default minimum grouping
* digits for the DecimalFormat/UNumberFormat setMinimumGroupingDigits method.
* Do not use these constants with the [U]NumberFormatter API.
*
* @stable ICU 68
*/
UNumberFormatMinimumGroupingDigits :: enum s32 {
    AUTO :: -2;

    MIN2 :: -3;
}

unum_open :: (style: UNumberFormatStyle, pattern: *UChar, patternLength: s32, locale: *u8, parseErr: *UParseError, status: *UErrorCode) -> *UNumberFormat #foreign libicutu "unum_open_73";

unum_close :: (fmt: *UNumberFormat) -> void #foreign libicutu "unum_close_73";

unum_clone :: (fmt: *UNumberFormat, status: *UErrorCode) -> *UNumberFormat #foreign libicutu "unum_clone_73";

unum_format :: (fmt: *UNumberFormat, number: s32, result: *UChar, resultLength: s32, pos: *UFieldPosition, status: *UErrorCode) -> s32 #foreign libicutu "unum_format_73";

unum_formatInt64 :: (fmt: *UNumberFormat, number: s64, result: *UChar, resultLength: s32, pos: *UFieldPosition, status: *UErrorCode) -> s32 #foreign libicutu "unum_formatInt64_73";

unum_formatDouble :: (fmt: *UNumberFormat, number: float64, result: *UChar, resultLength: s32, pos: *UFieldPosition, status: *UErrorCode) -> s32 #foreign libicutu "unum_formatDouble_73";

unum_formatDoubleForFields :: (format: *UNumberFormat, number: float64, result: *UChar, resultLength: s32, fpositer: *UFieldPositionIterator, status: *UErrorCode) -> s32 #foreign libicutu "unum_formatDoubleForFields_73";

unum_formatDecimal :: (fmt: *UNumberFormat, number: *u8, length: s32, result: *UChar, resultLength: s32, pos: *UFieldPosition, status: *UErrorCode) -> s32 #foreign libicutu "unum_formatDecimal_73";

unum_formatDoubleCurrency :: (fmt: *UNumberFormat, number: float64, currency: *UChar, result: *UChar, resultLength: s32, pos: *UFieldPosition, status: *UErrorCode) -> s32 #foreign libicutu "unum_formatDoubleCurrency_73";

unum_formatUFormattable :: (fmt: *UNumberFormat, number: *UFormattable, result: *UChar, resultLength: s32, pos: *UFieldPosition, status: *UErrorCode) -> s32 #foreign libicutu "unum_formatUFormattable_73";

unum_parse :: (fmt: *UNumberFormat, text: *UChar, textLength: s32, parsePos: *s32, status: *UErrorCode) -> s32 #foreign libicutu "unum_parse_73";

unum_parseInt64 :: (fmt: *UNumberFormat, text: *UChar, textLength: s32, parsePos: *s32, status: *UErrorCode) -> s64 #foreign libicutu "unum_parseInt64_73";

unum_parseDouble :: (fmt: *UNumberFormat, text: *UChar, textLength: s32, parsePos: *s32, status: *UErrorCode) -> float64 #foreign libicutu "unum_parseDouble_73";

unum_parseDecimal :: (fmt: *UNumberFormat, text: *UChar, textLength: s32, parsePos: *s32, outBuf: *u8, outBufLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "unum_parseDecimal_73";

unum_parseDoubleCurrency :: (fmt: *UNumberFormat, text: *UChar, textLength: s32, parsePos: *s32, currency: *UChar, status: *UErrorCode) -> float64 #foreign libicutu "unum_parseDoubleCurrency_73";

unum_parseToUFormattable :: (fmt: *UNumberFormat, result: *UFormattable, text: *UChar, textLength: s32, parsePos: *s32, status: *UErrorCode) -> *UFormattable #foreign libicutu "unum_parseToUFormattable_73";

unum_applyPattern :: (format: *UNumberFormat, localized: UBool, pattern: *UChar, patternLength: s32, parseError: *UParseError, status: *UErrorCode) -> void #foreign libicutu "unum_applyPattern_73";

unum_getAvailable :: (localeIndex: s32) -> *u8 #foreign libicutu "unum_getAvailable_73";

unum_countAvailable :: () -> s32 #foreign libicutu "unum_countAvailable_73";

/* The UNumberFormatAttributeValue type cannot be #ifndef U_HIDE_INTERNAL_API, needed for .h variable declaration */
/**
* @internal
*/
UNumberFormatAttributeValue :: enum u32 {
    NO    :: 0;

    YES   :: 1;

    MAYBE :: 2;
}

/** The possible UNumberFormat numeric attributes @stable ICU 2.0 */
UNumberFormatAttribute :: enum u32 {
    PARSE_INT_ONLY                      :: 0;

    GROUPING_USED                       :: 1;

    DECIMAL_ALWAYS_SHOWN                :: 2;

    MAX_INTEGER_DIGITS                  :: 3;

    MIN_INTEGER_DIGITS                  :: 4;

    INTEGER_DIGITS                      :: 5;

    MAX_FRACTION_DIGITS                 :: 6;

    MIN_FRACTION_DIGITS                 :: 7;

    FRACTION_DIGITS                     :: 8;

    MULTIPLIER                          :: 9;

    GROUPING_SIZE                       :: 10;

    ROUNDING_MODE                       :: 11;

    ROUNDING_INCREMENT                  :: 12;

    FORMAT_WIDTH                        :: 13;

    PADDING_POSITION                    :: 14;

    SECONDARY_GROUPING_SIZE             :: 15;

    SIGNIFICANT_DIGITS_USED             :: 16;

    MIN_SIGNIFICANT_DIGITS              :: 17;

    MAX_SIGNIFICANT_DIGITS              :: 18;

    LENIENT_PARSE                       :: 19;

    PARSE_ALL_INPUT                     :: 20;

    SCALE                               :: 21;

    MINIMUM_GROUPING_DIGITS             :: 22;

    CURRENCY_USAGE                      :: 23;

    MAX_NONBOOLEAN_ATTRIBUTE            :: 4095;

    FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS :: 4096;

    PARSE_NO_EXPONENT                   :: 4097;

    PARSE_DECIMAL_MARK_REQUIRED         :: 4098;

    PARSE_CASE_SENSITIVE                :: 4099;

    SIGN_ALWAYS_SHOWN                   :: 4100;

    LIMIT_BOOLEAN_ATTRIBUTE             :: 4101;
}

unum_hasAttribute :: (fmt: *UNumberFormat, attr: UNumberFormatAttribute) -> bool #foreign libicutu "unum_hasAttribute_73";

unum_getAttribute :: (fmt: *UNumberFormat, attr: UNumberFormatAttribute) -> s32 #foreign libicutu "unum_getAttribute_73";

unum_setAttribute :: (fmt: *UNumberFormat, attr: UNumberFormatAttribute, newValue: s32) -> void #foreign libicutu "unum_setAttribute_73";

unum_getDoubleAttribute :: (fmt: *UNumberFormat, attr: UNumberFormatAttribute) -> float64 #foreign libicutu "unum_getDoubleAttribute_73";

unum_setDoubleAttribute :: (fmt: *UNumberFormat, attr: UNumberFormatAttribute, newValue: float64) -> void #foreign libicutu "unum_setDoubleAttribute_73";

/** The possible UNumberFormat text attributes @stable ICU 2.0*/
UNumberFormatTextAttribute :: enum u32 {
    POSITIVE_PREFIX   :: 0;

    POSITIVE_SUFFIX   :: 1;

    NEGATIVE_PREFIX   :: 2;

    NEGATIVE_SUFFIX   :: 3;

    PADDING_CHARACTER :: 4;

    CURRENCY_CODE     :: 5;

    DEFAULT_RULESET   :: 6;

    PUBLIC_RULESETS   :: 7;
}

unum_getTextAttribute :: (fmt: *UNumberFormat, tag: UNumberFormatTextAttribute, result: *UChar, resultLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "unum_getTextAttribute_73";

unum_setTextAttribute :: (fmt: *UNumberFormat, tag: UNumberFormatTextAttribute, newValue: *UChar, newValueLength: s32, status: *UErrorCode) -> void #foreign libicutu "unum_setTextAttribute_73";

unum_toPattern :: (fmt: *UNumberFormat, isPatternLocalized: UBool, result: *UChar, resultLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "unum_toPattern_73";

/**
* Constants for specifying a number format symbol.
* @stable ICU 2.0
*/
UNumberFormatSymbol :: enum u32 {
    DECIMAL_SEPARATOR_SYMBOL           :: 0;

    GROUPING_SEPARATOR_SYMBOL          :: 1;

    PATTERN_SEPARATOR_SYMBOL           :: 2;

    PERCENT_SYMBOL                     :: 3;

    ZERO_DIGIT_SYMBOL                  :: 4;

    DIGIT_SYMBOL                       :: 5;

    MINUS_SIGN_SYMBOL                  :: 6;

    PLUS_SIGN_SYMBOL                   :: 7;

    CURRENCY_SYMBOL                    :: 8;

    INTL_CURRENCY_SYMBOL               :: 9;

    MONETARY_SEPARATOR_SYMBOL          :: 10;

    EXPONENTIAL_SYMBOL                 :: 11;

    PERMILL_SYMBOL                     :: 12;

    PAD_ESCAPE_SYMBOL                  :: 13;

    INFINITY_SYMBOL                    :: 14;

    NAN_SYMBOL                         :: 15;

    SIGNIFICANT_DIGIT_SYMBOL           :: 16;

    MONETARY_GROUPING_SEPARATOR_SYMBOL :: 17;

    ONE_DIGIT_SYMBOL                   :: 18;

    TWO_DIGIT_SYMBOL                   :: 19;

    THREE_DIGIT_SYMBOL                 :: 20;

    FOUR_DIGIT_SYMBOL                  :: 21;

    FIVE_DIGIT_SYMBOL                  :: 22;

    SIX_DIGIT_SYMBOL                   :: 23;

    SEVEN_DIGIT_SYMBOL                 :: 24;

    EIGHT_DIGIT_SYMBOL                 :: 25;

    NINE_DIGIT_SYMBOL                  :: 26;

    EXPONENT_MULTIPLICATION_SYMBOL     :: 27;

    APPROXIMATELY_SIGN_SYMBOL          :: 28;

    FORMAT_SYMBOL_COUNT                :: 29;
}

unum_getSymbol :: (fmt: *UNumberFormat, symbol: UNumberFormatSymbol, buffer: *UChar, size: s32, status: *UErrorCode) -> s32 #foreign libicutu "unum_getSymbol_73";

unum_setSymbol :: (fmt: *UNumberFormat, symbol: UNumberFormatSymbol, value: *UChar, length: s32, status: *UErrorCode) -> void #foreign libicutu "unum_setSymbol_73";

unum_getLocaleByType :: (fmt: *UNumberFormat, type: ULocDataLocaleType, status: *UErrorCode) -> *u8 #foreign libicutu "unum_getLocaleByType_73";

unum_setContext :: (fmt: *UNumberFormat, value: UDisplayContext, status: *UErrorCode) -> void #foreign libicutu "unum_setContext_73";

unum_getContext :: (fmt: *UNumberFormat, type: UDisplayContextType, status: *UErrorCode) -> UDisplayContext #foreign libicutu "unum_getContext_73";

/** A date formatter.
*  For usage in C programs.
*  @stable ICU 2.6
*/
UDateFormat :: *void;

/** The possible date/time format styles
*  @stable ICU 2.6
*/
UDateFormatStyle :: enum s32 {
    FULL            :: 0;

    LONG            :: 1;

    MEDIUM          :: 2;

    SHORT           :: 3;

    DEFAULT         :: 2;

    RELATIVE        :: 128;

    FULL_RELATIVE   :: 128;

    LONG_RELATIVE   :: 129;

    MEDIUM_RELATIVE :: 130;

    SHORT_RELATIVE  :: 131;

    NONE            :: -1;

    PATTERN         :: -2;

    IGNORE          :: -2;
}

/**
* FieldPosition and UFieldPosition selectors for format fields
* defined by DateFormat and UDateFormat.
* @stable ICU 3.0
*/
UDateFormatField :: enum u32 {
    ERA_FIELD                           :: 0;

    YEAR_FIELD                          :: 1;

    MONTH_FIELD                         :: 2;

    DATE_FIELD                          :: 3;

    HOUR_OF_DAY1_FIELD                  :: 4;

    HOUR_OF_DAY0_FIELD                  :: 5;

    MINUTE_FIELD                        :: 6;

    SECOND_FIELD                        :: 7;

    FRACTIONAL_SECOND_FIELD             :: 8;

    DAY_OF_WEEK_FIELD                   :: 9;

    DAY_OF_YEAR_FIELD                   :: 10;

    DAY_OF_WEEK_IN_MONTH_FIELD          :: 11;

    WEEK_OF_YEAR_FIELD                  :: 12;

    WEEK_OF_MONTH_FIELD                 :: 13;

    AM_PM_FIELD                         :: 14;

    HOUR1_FIELD                         :: 15;

    HOUR0_FIELD                         :: 16;

    TIMEZONE_FIELD                      :: 17;

    YEAR_WOY_FIELD                      :: 18;

    DOW_LOCAL_FIELD                     :: 19;

    EXTENDED_YEAR_FIELD                 :: 20;

    JULIAN_DAY_FIELD                    :: 21;

    MILLISECONDS_IN_DAY_FIELD           :: 22;

    TIMEZONE_RFC_FIELD                  :: 23;

    TIMEZONE_GENERIC_FIELD              :: 24;

    STANDALONE_DAY_FIELD                :: 25;

    STANDALONE_MONTH_FIELD              :: 26;

    QUARTER_FIELD                       :: 27;

    STANDALONE_QUARTER_FIELD            :: 28;

    TIMEZONE_SPECIAL_FIELD              :: 29;

    YEAR_NAME_FIELD                     :: 30;

    TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD :: 31;

    TIMEZONE_ISO_FIELD                  :: 32;

    TIMEZONE_ISO_LOCAL_FIELD            :: 33;

    RELATED_YEAR_FIELD                  :: 34;

    AM_PM_MIDNIGHT_NOON_FIELD           :: 35;

    FLEXIBLE_DAY_PERIOD_FIELD           :: 36;

    TIME_SEPARATOR_FIELD                :: 37;

    FIELD_COUNT                         :: 38;
}

udat_toCalendarDateField :: (field: UDateFormatField) -> UCalendarDateFields #foreign libicutu "udat_toCalendarDateField_73";

udat_open :: (timeStyle: UDateFormatStyle, dateStyle: UDateFormatStyle, locale: *u8, tzID: *UChar, tzIDLength: s32, pattern: *UChar, patternLength: s32, status: *UErrorCode) -> *UDateFormat #foreign libicutu "udat_open_73";

udat_close :: (format: *UDateFormat) -> void #foreign libicutu "udat_close_73";

/**
* DateFormat boolean attributes
*
* @stable ICU 53
*/
UDateFormatBooleanAttribute :: enum u32 {
    PARSE_ALLOW_WHITESPACE            :: 0;

    PARSE_ALLOW_NUMERIC               :: 1;

    PARSE_PARTIAL_LITERAL_MATCH       :: 2;

    PARSE_MULTIPLE_PATTERNS_FOR_MATCH :: 3;

    BOOLEAN_ATTRIBUTE_COUNT           :: 4;
}

udat_getBooleanAttribute :: (fmt: *UDateFormat, attr: UDateFormatBooleanAttribute, status: *UErrorCode) -> UBool #foreign libicutu "udat_getBooleanAttribute_73";

udat_setBooleanAttribute :: (fmt: *UDateFormat, attr: UDateFormatBooleanAttribute, newValue: UBool, status: *UErrorCode) -> void #foreign libicutu "udat_setBooleanAttribute_73";

/**
* Hour Cycle.
* @stable ICU 67
*/
UDateFormatHourCycle :: enum u32 {
    _11 :: 0;

    _12 :: 1;

    _23 :: 2;

    _24 :: 3;
}

udat_clone :: (fmt: *UDateFormat, status: *UErrorCode) -> *UDateFormat #foreign libicutu "udat_clone_73";

udat_format :: (format: *UDateFormat, dateToFormat: UDate, result: *UChar, resultLength: s32, position: *UFieldPosition, status: *UErrorCode) -> s32 #foreign libicutu "udat_format_73";

udat_formatCalendar :: (format: *UDateFormat, calendar: *UCalendar, result: *UChar, capacity: s32, position: *UFieldPosition, status: *UErrorCode) -> s32 #foreign libicutu "udat_formatCalendar_73";

udat_formatForFields :: (format: *UDateFormat, dateToFormat: UDate, result: *UChar, resultLength: s32, fpositer: *UFieldPositionIterator, status: *UErrorCode) -> s32 #foreign libicutu "udat_formatForFields_73";

udat_formatCalendarForFields :: (format: *UDateFormat, calendar: *UCalendar, result: *UChar, capacity: s32, fpositer: *UFieldPositionIterator, status: *UErrorCode) -> s32 #foreign libicutu "udat_formatCalendarForFields_73";

udat_parse :: (format: *UDateFormat, text: *UChar, textLength: s32, parsePos: *s32, status: *UErrorCode) -> UDate #foreign libicutu "udat_parse_73";

udat_parseCalendar :: (format: *UDateFormat, calendar: *UCalendar, text: *UChar, textLength: s32, parsePos: *s32, status: *UErrorCode) -> void #foreign libicutu "udat_parseCalendar_73";

udat_isLenient :: (fmt: *UDateFormat) -> UBool #foreign libicutu "udat_isLenient_73";

udat_setLenient :: (fmt: *UDateFormat, isLenient: UBool) -> void #foreign libicutu "udat_setLenient_73";

udat_getCalendar :: (fmt: *UDateFormat) -> *UCalendar #foreign libicutu "udat_getCalendar_73";

udat_setCalendar :: (fmt: *UDateFormat, calendarToSet: *UCalendar) -> void #foreign libicutu "udat_setCalendar_73";

udat_getNumberFormat :: (fmt: *UDateFormat) -> *UNumberFormat #foreign libicutu "udat_getNumberFormat_73";

udat_getNumberFormatForField :: (fmt: *UDateFormat, field: UChar) -> *UNumberFormat #foreign libicutu "udat_getNumberFormatForField_73";

udat_adoptNumberFormatForFields :: (fmt: *UDateFormat, fields: *UChar, numberFormatToSet: *UNumberFormat, status: *UErrorCode) -> void #foreign libicutu "udat_adoptNumberFormatForFields_73";

udat_setNumberFormat :: (fmt: *UDateFormat, numberFormatToSet: *UNumberFormat) -> void #foreign libicutu "udat_setNumberFormat_73";

udat_adoptNumberFormat :: (fmt: *UDateFormat, numberFormatToAdopt: *UNumberFormat) -> void #foreign libicutu "udat_adoptNumberFormat_73";

udat_getAvailable :: (localeIndex: s32) -> *u8 #foreign libicutu "udat_getAvailable_73";

udat_countAvailable :: () -> s32 #foreign libicutu "udat_countAvailable_73";

udat_get2DigitYearStart :: (fmt: *UDateFormat, status: *UErrorCode) -> UDate #foreign libicutu "udat_get2DigitYearStart_73";

udat_set2DigitYearStart :: (fmt: *UDateFormat, d: UDate, status: *UErrorCode) -> void #foreign libicutu "udat_set2DigitYearStart_73";

udat_toPattern :: (fmt: *UDateFormat, localized: UBool, result: *UChar, resultLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "udat_toPattern_73";

udat_applyPattern :: (format: *UDateFormat, localized: UBool, pattern: *UChar, patternLength: s32) -> void #foreign libicutu "udat_applyPattern_73";

/**
* The possible types of date format symbols
* @stable ICU 2.6
*/
UDateFormatSymbolType :: enum u32 {
    ERAS                        :: 0;

    MONTHS                      :: 1;

    SHORT_MONTHS                :: 2;

    WEEKDAYS                    :: 3;

    SHORT_WEEKDAYS              :: 4;

    AM_PMS                      :: 5;

    LOCALIZED_CHARS             :: 6;

    ERA_NAMES                   :: 7;

    NARROW_MONTHS               :: 8;

    NARROW_WEEKDAYS             :: 9;

    STANDALONE_MONTHS           :: 10;
    STANDALONE_SHORT_MONTHS     :: 11;
    STANDALONE_NARROW_MONTHS    :: 12;

    STANDALONE_WEEKDAYS         :: 13;

    STANDALONE_SHORT_WEEKDAYS   :: 14;

    STANDALONE_NARROW_WEEKDAYS  :: 15;

    QUARTERS                    :: 16;

    SHORT_QUARTERS              :: 17;

    STANDALONE_QUARTERS         :: 18;
    STANDALONE_SHORT_QUARTERS   :: 19;

    SHORTER_WEEKDAYS            :: 20;

    STANDALONE_SHORTER_WEEKDAYS :: 21;

    CYCLIC_YEARS_WIDE           :: 22;

    CYCLIC_YEARS_ABBREVIATED    :: 23;

    CYCLIC_YEARS_NARROW         :: 24;

    ZODIAC_NAMES_WIDE           :: 25;

    ZODIAC_NAMES_ABBREVIATED    :: 26;

    ZODIAC_NAMES_NARROW         :: 27;

    NARROW_QUARTERS             :: 28;

    STANDALONE_NARROW_QUARTERS  :: 29;
}

UDateFormatSymbols :: struct {}

udat_getSymbols :: (fmt: *UDateFormat, type: UDateFormatSymbolType, symbolIndex: s32, result: *UChar, resultLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "udat_getSymbols_73";

udat_countSymbols :: (fmt: *UDateFormat, type: UDateFormatSymbolType) -> s32 #foreign libicutu "udat_countSymbols_73";

udat_setSymbols :: (format: *UDateFormat, type: UDateFormatSymbolType, symbolIndex: s32, value: *UChar, valueLength: s32, status: *UErrorCode) -> void #foreign libicutu "udat_setSymbols_73";

udat_getLocaleByType :: (fmt: *UDateFormat, type: ULocDataLocaleType, status: *UErrorCode) -> *u8 #foreign libicutu "udat_getLocaleByType_73";

udat_setContext :: (fmt: *UDateFormat, value: UDisplayContext, status: *UErrorCode) -> void #foreign libicutu "udat_setContext_73";

udat_getContext :: (fmt: *UDateFormat, type: UDisplayContextType, status: *UErrorCode) -> UDisplayContext #foreign libicutu "udat_getContext_73";

udat_toPatternRelativeDate :: (fmt: *UDateFormat, result: *UChar, resultLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "udat_toPatternRelativeDate_73";

udat_toPatternRelativeTime :: (fmt: *UDateFormat, result: *UChar, resultLength: s32, status: *UErrorCode) -> s32 #foreign libicutu "udat_toPatternRelativeTime_73";

udat_applyPatternRelative :: (format: *UDateFormat, datePattern: *UChar, datePatternLength: s32, timePattern: *UChar, timePatternLength: s32, status: *UErrorCode) -> void #foreign libicutu "udat_applyPatternRelative_73";

/**
* @internal
* @see udat_open
*/
UDateFormatOpener :: #type (timeStyle: UDateFormatStyle, dateStyle: UDateFormatStyle, locale: *u8, tzID: *UChar, tzIDLength: s32, pattern: *UChar, patternLength: s32, status: *UErrorCode) -> *UDateFormat #c_call;

udat_registerOpener :: (opener: UDateFormatOpener, status: *UErrorCode) -> void #foreign libicutu "udat_registerOpener_73";

udat_unregisterOpener :: (opener: UDateFormatOpener, status: *UErrorCode) -> UDateFormatOpener #foreign libicutu "udat_unregisterOpener_73";

u_getDataDirectory :: () -> *u8 #foreign libicutu "u_getDataDirectory_73";

u_setDataDirectory :: (directory: *u8) -> void #foreign libicutu "u_setDataDirectory_73";

u_getTimeZoneFilesDirectory :: (status: *UErrorCode) -> *u8 #foreign libicutu "u_getTimeZoneFilesDirectory_73";

u_setTimeZoneFilesDirectory :: (path: *u8, status: *UErrorCode) -> void #foreign libicutu "u_setTimeZoneFilesDirectory_73";

u_charsToUChars :: (cs: *u8, us: *UChar, length: s32) -> void #foreign libicutu "u_charsToUChars_73";

u_UCharsToChars :: (us: *UChar, cs: *u8, length: s32) -> void #foreign libicutu "u_UCharsToChars_73";

/**
* Origin constants for UCharIterator.getIndex() and UCharIterator.move().
* @see UCharIteratorMove
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorOrigin :: enum u32 {
    START   :: 0;
    CURRENT :: 1;
    LIMIT   :: 2;
    ZERO    :: 3;
    LENGTH  :: 4;
}

/** Constants for UCharIterator. @stable ICU 2.6 */
anon_enum_1 :: enum s32 {
    UITER_UNKNOWN_INDEX :: -2;
}

/**
* Function type declaration for UCharIterator.getIndex().
*
* Gets the current position, or the start or limit of the
* iteration range.
*
* This function may perform slowly for UITER_CURRENT after setState() was called,
* or for UITER_LENGTH, because an iterator implementation may have to count
* UChars if the underlying storage is not UTF-16.
*
* @param iter the UCharIterator structure ("this pointer")
* @param origin get the 0, start, limit, length, or current index
* @return the requested index, or U_SENTINEL in an error condition
*
* @see UCharIteratorOrigin
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorGetIndex :: #type (iter: *UCharIterator, origin: UCharIteratorOrigin) -> s32 #c_call;

/**
* Function type declaration for UCharIterator.move().
*
* Use iter->move(iter, index, UITER_ZERO) like CharacterIterator::setIndex(index).
*
* Moves the current position relative to the start or limit of the
* iteration range, or relative to the current position itself.
* The movement is expressed in numbers of code units forward
* or backward by specifying a positive or negative delta.
* Out of bounds movement will be pinned to the start or limit.
*
* This function may perform slowly for moving relative to UITER_LENGTH
* because an iterator implementation may have to count the rest of the
* UChars if the native storage is not UTF-16.
*
* When moving relative to the limit or length, or
* relative to the current position after setState() was called,
* move() may return UITER_UNKNOWN_INDEX (-2) to avoid an inefficient
* determination of the actual UTF-16 index.
* The actual index can be determined with getIndex(UITER_CURRENT)
* which will count the UChars if necessary.
* See UITER_UNKNOWN_INDEX for details.
*
* @param iter the UCharIterator structure ("this pointer")
* @param delta can be positive, zero, or negative
* @param origin move relative to the 0, start, limit, length, or current index
* @return the new index, or U_SENTINEL on an error condition,
*         or UITER_UNKNOWN_INDEX when the index is not known.
*
* @see UCharIteratorOrigin
* @see UCharIterator
* @see UITER_UNKNOWN_INDEX
* @stable ICU 2.1
*/
UCharIteratorMove :: #type (iter: *UCharIterator, delta: s32, origin: UCharIteratorOrigin) -> s32 #c_call;

/**
* Function type declaration for UCharIterator.hasNext().
*
* Check if current() and next() can still
* return another code unit.
*
* @param iter the UCharIterator structure ("this pointer")
* @return boolean value for whether current() and next() can still return another code unit
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorHasNext :: #type (iter: *UCharIterator) -> UBool #c_call;

/**
* Function type declaration for UCharIterator.hasPrevious().
*
* Check if previous() can still return another code unit.
*
* @param iter the UCharIterator structure ("this pointer")
* @return boolean value for whether previous() can still return another code unit
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorHasPrevious :: #type (iter: *UCharIterator) -> UBool #c_call;

/**
* Function type declaration for UCharIterator.current().
*
* Return the code unit at the current position,
* or U_SENTINEL if there is none (index is at the limit).
*
* @param iter the UCharIterator structure ("this pointer")
* @return the current code unit
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorCurrent :: #type (iter: *UCharIterator) -> UChar32 #c_call;

/**
* Function type declaration for UCharIterator.next().
*
* Return the code unit at the current index and increment
* the index (post-increment, like s[i++]),
* or return U_SENTINEL if there is none (index is at the limit).
*
* @param iter the UCharIterator structure ("this pointer")
* @return the current code unit (and post-increment the current index)
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorNext :: #type (iter: *UCharIterator) -> UChar32 #c_call;

/**
* Function type declaration for UCharIterator.previous().
*
* Decrement the index and return the code unit from there
* (pre-decrement, like s[--i]),
* or return U_SENTINEL if there is none (index is at the start).
*
* @param iter the UCharIterator structure ("this pointer")
* @return the previous code unit (after pre-decrementing the current index)
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorPrevious :: #type (iter: *UCharIterator) -> UChar32 #c_call;

/**
* Function type declaration for UCharIterator.reservedFn().
* Reserved for future use.
*
* @param iter the UCharIterator structure ("this pointer")
* @param something some integer argument
* @return some integer
*
* @see UCharIterator
* @stable ICU 2.1
*/
UCharIteratorReserved :: #type (iter: *UCharIterator, something: s32) -> s32 #c_call;

/**
* Function type declaration for UCharIterator.getState().
*
* Get the "state" of the iterator in the form of a single 32-bit word.
* It is recommended that the state value be calculated to be as small as
* is feasible. For strings with limited lengths, fewer than 32 bits may
* be sufficient.
*
* This is used together with setState()/UCharIteratorSetState
* to save and restore the iterator position more efficiently than with
* getIndex()/move().
*
* The iterator state is defined as a uint32_t value because it is designed
* for use in ucol_nextSortKeyPart() which provides 32 bits to store the state
* of the character iterator.
*
* With some UCharIterator implementations (e.g., UTF-8),
* getting and setting the UTF-16 index with existing functions
* (getIndex(UITER_CURRENT) followed by move(pos, UITER_ZERO)) is possible but
* relatively slow because the iterator has to "walk" from a known index
* to the requested one.
* This takes more time the farther it needs to go.
*
* An opaque state value allows an iterator implementation to provide
* an internal index (UTF-8: the source byte array index) for
* fast, constant-time restoration.
*
* After calling setState(), a getIndex(UITER_CURRENT) may be slow because
* the UTF-16 index may not be restored as well, but the iterator can deliver
* the correct text contents and move relative to the current position
* without performance degradation.
*
* Some UCharIterator implementations may not be able to return
* a valid state for each position, in which case they return UITER_NO_STATE instead.
* This will be clearly documented for each such iterator (none of the public ones here).
*
* @param iter the UCharIterator structure ("this pointer")
* @return the state word
*
* @see UCharIterator
* @see UCharIteratorSetState
* @see UITER_NO_STATE
* @stable ICU 2.6
*/
UCharIteratorGetState :: #type (iter: *UCharIterator) -> u32 #c_call;

/**
* Function type declaration for UCharIterator.setState().
*
* Restore the "state" of the iterator using a state word from a getState() call.
* The iterator object need not be the same one as for which getState() was called,
* but it must be of the same type (set up using the same uiter_setXYZ function)
* and it must iterate over the same string
* (binary identical regardless of memory address).
* For more about the state word see UCharIteratorGetState.
*
* After calling setState(), a getIndex(UITER_CURRENT) may be slow because
* the UTF-16 index may not be restored as well, but the iterator can deliver
* the correct text contents and move relative to the current position
* without performance degradation.
*
* @param iter the UCharIterator structure ("this pointer")
* @param state the state word from a getState() call
*              on a same-type, same-string iterator
* @param pErrorCode Must be a valid pointer to an error code value,
*                   which must not indicate a failure before the function call.
*
* @see UCharIterator
* @see UCharIteratorGetState
* @stable ICU 2.6
*/
UCharIteratorSetState :: #type (iter: *UCharIterator, state: u32, pErrorCode: *UErrorCode) -> void #c_call;

/**
* C API for code unit iteration.
* This can be used as a C wrapper around
* CharacterIterator, Replaceable, or implemented using simple strings, etc.
*
* There are two roles for using UCharIterator:
*
* A "provider" sets the necessary function pointers and controls the "protected"
* fields of the UCharIterator structure. A "provider" passes a UCharIterator
* into C APIs that need a UCharIterator as an abstract, flexible string interface.
*
* Implementations of such C APIs are "callers" of UCharIterator functions;
* they only use the "public" function pointers and never access the "protected"
* fields directly.
*
* The current() and next() functions only check the current index against the
* limit, and previous() only checks the current index against the start,
* to see if the iterator already reached the end of the iteration range.
*
* The assumption - in all iterators - is that the index is moved via the API,
* which means it won't go out of bounds, or the index is modified by
* user code that knows enough about the iterator implementation to set valid
* index values.
*
* UCharIterator functions return code unit values 0..0xffff,
* or U_SENTINEL if the iteration bounds are reached.
*
* @stable ICU 2.1
*/
UCharIterator :: struct {
    /**
    * (protected) Pointer to string or wrapped object or similar.
    * Not used by caller.
    * @stable ICU 2.1
    */
    _context:      *void;

    /**
    * (protected) Length of string or similar.
    * Not used by caller.
    * @stable ICU 2.1
    */
    length:        s32;

    /**
    * (protected) Start index or similar.
    * Not used by caller.
    * @stable ICU 2.1
    */
    start:         s32;

    /**
    * (protected) Current index or similar.
    * Not used by caller.
    * @stable ICU 2.1
    */
    index:         s32;

    /**
    * (protected) Limit index or similar.
    * Not used by caller.
    * @stable ICU 2.1
    */
    limit:         s32;

    /**
    * (protected) Used by UTF-8 iterators and possibly others.
    * @stable ICU 2.1
    */
    reservedField: s32;

    /**
    * (public) Returns the current position or the
    * start or limit index of the iteration range.
    *
    * @see UCharIteratorGetIndex
    * @stable ICU 2.1
    */
    getIndex:      UCharIteratorGetIndex;

    /**
    * (public) Moves the current position relative to the start or limit of the
    * iteration range, or relative to the current position itself.
    * The movement is expressed in numbers of code units forward
    * or backward by specifying a positive or negative delta.
    *
    * @see UCharIteratorMove
    * @stable ICU 2.1
    */
    move:          UCharIteratorMove;

    /**
    * (public) Check if current() and next() can still
    * return another code unit.
    *
    * @see UCharIteratorHasNext
    * @stable ICU 2.1
    */
    hasNext:       UCharIteratorHasNext;

    /**
    * (public) Check if previous() can still return another code unit.
    *
    * @see UCharIteratorHasPrevious
    * @stable ICU 2.1
    */
    hasPrevious:   UCharIteratorHasPrevious;

    /**
    * (public) Return the code unit at the current position,
    * or U_SENTINEL if there is none (index is at the limit).
    *
    * @see UCharIteratorCurrent
    * @stable ICU 2.1
    */
    current:       UCharIteratorCurrent;

    /**
    * (public) Return the code unit at the current index and increment
    * the index (post-increment, like s[i++]),
    * or return U_SENTINEL if there is none (index is at the limit).
    *
    * @see UCharIteratorNext
    * @stable ICU 2.1
    */
    next:          UCharIteratorNext;

    /**
    * (public) Decrement the index and return the code unit from there
    * (pre-decrement, like s[--i]),
    * or return U_SENTINEL if there is none (index is at the start).
    *
    * @see UCharIteratorPrevious
    * @stable ICU 2.1
    */
    previous:      UCharIteratorPrevious;

    /**
    * (public) Reserved for future use. Currently NULL.
    *
    * @see UCharIteratorReserved
    * @stable ICU 2.1
    */
    reservedFn:    UCharIteratorReserved;

    /**
    * (public) Return the state of the iterator, to be restored later with setState().
    * This function pointer is NULL if the iterator does not implement it.
    *
    * @see UCharIteratorGet
    * @stable ICU 2.6
    */
    getState:      UCharIteratorGetState;

    /**
    * (public) Restore the iterator state from the state word from a call
    * to getState().
    * This function pointer is NULL if the iterator does not implement it.
    *
    * @see UCharIteratorSet
    * @stable ICU 2.6
    */
    setState:      UCharIteratorSetState;
}

uiter_current32 :: (iter: *UCharIterator) -> UChar32 #foreign libicutu "uiter_current32_73";

uiter_next32 :: (iter: *UCharIterator) -> UChar32 #foreign libicutu "uiter_next32_73";

uiter_previous32 :: (iter: *UCharIterator) -> UChar32 #foreign libicutu "uiter_previous32_73";

uiter_getState :: (iter: *UCharIterator) -> u32 #foreign libicutu "uiter_getState_73";

uiter_setState :: (iter: *UCharIterator, state: u32, pErrorCode: *UErrorCode) -> void #foreign libicutu "uiter_setState_73";

uiter_setString :: (iter: *UCharIterator, s: *UChar, length: s32) -> void #foreign libicutu "uiter_setString_73";

uiter_setUTF16BE :: (iter: *UCharIterator, s: *u8, length: s32) -> void #foreign libicutu "uiter_setUTF16BE_73";

uiter_setUTF8 :: (iter: *UCharIterator, s: *u8, length: s32) -> void #foreign libicutu "uiter_setUTF8_73";

UBreakIterator :: struct {}

u_strlen :: (s: *UChar) -> s32 #foreign libicutu "u_strlen_73";

u_countChar32 :: (s: *UChar, length: s32) -> s32 #foreign libicutu "u_countChar32_73";

u_strHasMoreChar32Than :: (s: *UChar, length: s32, number: s32) -> UBool #foreign libicutu "u_strHasMoreChar32Than_73";

u_strcat :: (dst: *UChar, src: *UChar) -> *UChar #foreign libicutu "u_strcat_73";

u_strncat :: (dst: *UChar, src: *UChar, n: s32) -> *UChar #foreign libicutu "u_strncat_73";

u_strstr :: (s: *UChar, substring: *UChar) -> *UChar #foreign libicutu "u_strstr_73";

u_strFindFirst :: (s: *UChar, length: s32, substring: *UChar, subLength: s32) -> *UChar #foreign libicutu "u_strFindFirst_73";

u_strchr :: (s: *UChar, c: UChar) -> *UChar #foreign libicutu "u_strchr_73";

u_strchr32 :: (s: *UChar, c: UChar32) -> *UChar #foreign libicutu "u_strchr32_73";

u_strrstr :: (s: *UChar, substring: *UChar) -> *UChar #foreign libicutu "u_strrstr_73";

u_strFindLast :: (s: *UChar, length: s32, substring: *UChar, subLength: s32) -> *UChar #foreign libicutu "u_strFindLast_73";

u_strrchr :: (s: *UChar, c: UChar) -> *UChar #foreign libicutu "u_strrchr_73";

u_strrchr32 :: (s: *UChar, c: UChar32) -> *UChar #foreign libicutu "u_strrchr32_73";

u_strpbrk :: (_string: *UChar, matchSet: *UChar) -> *UChar #foreign libicutu "u_strpbrk_73";

u_strcspn :: (_string: *UChar, matchSet: *UChar) -> s32 #foreign libicutu "u_strcspn_73";

u_strspn :: (_string: *UChar, matchSet: *UChar) -> s32 #foreign libicutu "u_strspn_73";

u_strtok_r :: (src: *UChar, delim: *UChar, saveState: **UChar) -> *UChar #foreign libicutu "u_strtok_r_73";

u_strcmp :: (s1: *UChar, s2: *UChar) -> s32 #foreign libicutu "u_strcmp_73";

u_strcmpCodePointOrder :: (s1: *UChar, s2: *UChar) -> s32 #foreign libicutu "u_strcmpCodePointOrder_73";

u_strCompare :: (s1: *UChar, length1: s32, s2: *UChar, length2: s32, codePointOrder: UBool) -> s32 #foreign libicutu "u_strCompare_73";

u_strCompareIter :: (iter1: *UCharIterator, iter2: *UCharIterator, codePointOrder: UBool) -> s32 #foreign libicutu "u_strCompareIter_73";

u_strCaseCompare :: (s1: *UChar, length1: s32, s2: *UChar, length2: s32, options: u32, pErrorCode: *UErrorCode) -> s32 #foreign libicutu "u_strCaseCompare_73";

u_strncmp :: (ucs1: *UChar, ucs2: *UChar, n: s32) -> s32 #foreign libicutu "u_strncmp_73";

u_strncmpCodePointOrder :: (s1: *UChar, s2: *UChar, n: s32) -> s32 #foreign libicutu "u_strncmpCodePointOrder_73";

u_strcasecmp :: (s1: *UChar, s2: *UChar, options: u32) -> s32 #foreign libicutu "u_strcasecmp_73";

u_strncasecmp :: (s1: *UChar, s2: *UChar, n: s32, options: u32) -> s32 #foreign libicutu "u_strncasecmp_73";

u_memcasecmp :: (s1: *UChar, s2: *UChar, length: s32, options: u32) -> s32 #foreign libicutu "u_memcasecmp_73";

u_strcpy :: (dst: *UChar, src: *UChar) -> *UChar #foreign libicutu "u_strcpy_73";

u_strncpy :: (dst: *UChar, src: *UChar, n: s32) -> *UChar #foreign libicutu "u_strncpy_73";

u_uastrcpy :: (dst: *UChar, src: *u8) -> *UChar #foreign libicutu "u_uastrcpy_73";

u_uastrncpy :: (dst: *UChar, src: *u8, n: s32) -> *UChar #foreign libicutu "u_uastrncpy_73";

u_austrcpy :: (dst: *u8, src: *UChar) -> *u8 #foreign libicutu "u_austrcpy_73";

u_austrncpy :: (dst: *u8, src: *UChar, n: s32) -> *u8 #foreign libicutu "u_austrncpy_73";

u_memcpy :: (dest: *UChar, src: *UChar, count: s32) -> *UChar #foreign libicutu "u_memcpy_73";

u_memmove :: (dest: *UChar, src: *UChar, count: s32) -> *UChar #foreign libicutu "u_memmove_73";

u_memset :: (dest: *UChar, c: UChar, count: s32) -> *UChar #foreign libicutu "u_memset_73";

u_memcmp :: (buf1: *UChar, buf2: *UChar, count: s32) -> s32 #foreign libicutu "u_memcmp_73";

u_memcmpCodePointOrder :: (s1: *UChar, s2: *UChar, count: s32) -> s32 #foreign libicutu "u_memcmpCodePointOrder_73";

u_memchr :: (s: *UChar, c: UChar, count: s32) -> *UChar #foreign libicutu "u_memchr_73";

u_memchr32 :: (s: *UChar, c: UChar32, count: s32) -> *UChar #foreign libicutu "u_memchr32_73";

u_memrchr :: (s: *UChar, c: UChar, count: s32) -> *UChar #foreign libicutu "u_memrchr_73";

u_memrchr32 :: (s: *UChar, c: UChar32, count: s32) -> *UChar #foreign libicutu "u_memrchr32_73";

u_unescape :: (src: *u8, dest: *UChar, destCapacity: s32) -> s32 #foreign libicutu "u_unescape_73";

/**
* Callback function for u_unescapeAt() that returns a character of
* the source text given an offset and a context pointer.  The context
* pointer will be whatever is passed into u_unescapeAt().
*
* @param offset pointer to the offset that will be passed to u_unescapeAt().
* @param context an opaque pointer passed directly into u_unescapeAt()
* @return the character represented by the escape sequence at
* offset
* @see u_unescapeAt
* @stable ICU 2.0
*/
UNESCAPE_CHAR_AT :: #type (offset: s32, _context: *void) -> UChar #c_call;

u_unescapeAt :: (charAt: UNESCAPE_CHAR_AT, offset: *s32, length: s32, _context: *void) -> UChar32 #foreign libicutu "u_unescapeAt_73";

u_strToUpper :: (dest: *UChar, destCapacity: s32, src: *UChar, srcLength: s32, locale: *u8, pErrorCode: *UErrorCode) -> s32 #foreign libicutu "u_strToUpper_73";

u_strToLower :: (dest: *UChar, destCapacity: s32, src: *UChar, srcLength: s32, locale: *u8, pErrorCode: *UErrorCode) -> s32 #foreign libicutu "u_strToLower_73";

u_strToTitle :: (dest: *UChar, destCapacity: s32, src: *UChar, srcLength: s32, titleIter: *UBreakIterator, locale: *u8, pErrorCode: *UErrorCode) -> s32 #foreign libicutu "u_strToTitle_73";

u_strFoldCase :: (dest: *UChar, destCapacity: s32, src: *UChar, srcLength: s32, options: u32, pErrorCode: *UErrorCode) -> s32 #foreign libicutu "u_strFoldCase_73";

u_strToWCS :: (dest: *wchar_t, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, pErrorCode: *UErrorCode) -> *wchar_t #foreign libicutu "u_strToWCS_73";

u_strFromWCS :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *wchar_t, srcLength: s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromWCS_73";

u_strToUTF8 :: (dest: *u8, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, pErrorCode: *UErrorCode) -> *u8 #foreign libicutu "u_strToUTF8_73";

u_strFromUTF8 :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *u8, srcLength: s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromUTF8_73";

u_strToUTF8WithSub :: (dest: *u8, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, subchar: UChar32, pNumSubstitutions: *s32, pErrorCode: *UErrorCode) -> *u8 #foreign libicutu "u_strToUTF8WithSub_73";

u_strFromUTF8WithSub :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *u8, srcLength: s32, subchar: UChar32, pNumSubstitutions: *s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromUTF8WithSub_73";

u_strFromUTF8Lenient :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *u8, srcLength: s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromUTF8Lenient_73";

u_strToUTF32 :: (dest: *UChar32, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, pErrorCode: *UErrorCode) -> *UChar32 #foreign libicutu "u_strToUTF32_73";

u_strFromUTF32 :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *UChar32, srcLength: s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromUTF32_73";

u_strToUTF32WithSub :: (dest: *UChar32, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, subchar: UChar32, pNumSubstitutions: *s32, pErrorCode: *UErrorCode) -> *UChar32 #foreign libicutu "u_strToUTF32WithSub_73";

u_strFromUTF32WithSub :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *UChar32, srcLength: s32, subchar: UChar32, pNumSubstitutions: *s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromUTF32WithSub_73";

u_strToJavaModifiedUTF8 :: (dest: *u8, destCapacity: s32, pDestLength: *s32, src: *UChar, srcLength: s32, pErrorCode: *UErrorCode) -> *u8 #foreign libicutu "u_strToJavaModifiedUTF8_73";

u_strFromJavaModifiedUTF8WithSub :: (dest: *UChar, destCapacity: s32, pDestLength: *s32, src: *u8, srcLength: s32, subchar: UChar32, pNumSubstitutions: *s32, pErrorCode: *UErrorCode) -> *UChar #foreign libicutu "u_strFromJavaModifiedUTF8WithSub_73";

#scope_file

#import "Basic"; // For assert


#run {
    {
        instance: UFieldPosition;
        assert(((cast(*void)(*instance.field)) - cast(*void)(*instance)) == 0, "UFieldPosition.field has unexpected offset % instead of 0", ((cast(*void)(*instance.field)) - cast(*void)(*instance)));
        assert(size_of(type_of(UFieldPosition.field)) == 4, "UFieldPosition.field has unexpected size % instead of 4", size_of(type_of(UFieldPosition.field)));
        assert(((cast(*void)(*instance.beginIndex)) - cast(*void)(*instance)) == 4, "UFieldPosition.beginIndex has unexpected offset % instead of 4", ((cast(*void)(*instance.beginIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(UFieldPosition.beginIndex)) == 4, "UFieldPosition.beginIndex has unexpected size % instead of 4", size_of(type_of(UFieldPosition.beginIndex)));
        assert(((cast(*void)(*instance.endIndex)) - cast(*void)(*instance)) == 8, "UFieldPosition.endIndex has unexpected offset % instead of 8", ((cast(*void)(*instance.endIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(UFieldPosition.endIndex)) == 4, "UFieldPosition.endIndex has unexpected size % instead of 4", size_of(type_of(UFieldPosition.endIndex)));
        assert(size_of(UFieldPosition) == 12, "UFieldPosition has size % instead of 12", size_of(UFieldPosition));
    }

    {
        instance: UParseError;
        assert(((cast(*void)(*instance.line)) - cast(*void)(*instance)) == 0, "UParseError.line has unexpected offset % instead of 0", ((cast(*void)(*instance.line)) - cast(*void)(*instance)));
        assert(size_of(type_of(UParseError.line)) == 4, "UParseError.line has unexpected size % instead of 4", size_of(type_of(UParseError.line)));
        assert(((cast(*void)(*instance.offset)) - cast(*void)(*instance)) == 4, "UParseError.offset has unexpected offset % instead of 4", ((cast(*void)(*instance.offset)) - cast(*void)(*instance)));
        assert(size_of(type_of(UParseError.offset)) == 4, "UParseError.offset has unexpected size % instead of 4", size_of(type_of(UParseError.offset)));
        assert(((cast(*void)(*instance.preContext)) - cast(*void)(*instance)) == 8, "UParseError.preContext has unexpected offset % instead of 8", ((cast(*void)(*instance.preContext)) - cast(*void)(*instance)));
        assert(size_of(type_of(UParseError.preContext)) == 32, "UParseError.preContext has unexpected size % instead of 32", size_of(type_of(UParseError.preContext)));
        assert(((cast(*void)(*instance.postContext)) - cast(*void)(*instance)) == 40, "UParseError.postContext has unexpected offset % instead of 40", ((cast(*void)(*instance.postContext)) - cast(*void)(*instance)));
        assert(size_of(type_of(UParseError.postContext)) == 32, "UParseError.postContext has unexpected size % instead of 32", size_of(type_of(UParseError.postContext)));
        assert(size_of(UParseError) == 72, "UParseError has size % instead of 72", size_of(UParseError));
    }

    {
        instance: UCharIterator;
        assert(((cast(*void)(*instance._context)) - cast(*void)(*instance)) == 0, "UCharIterator._context has unexpected offset % instead of 0", ((cast(*void)(*instance._context)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator._context)) == 8, "UCharIterator._context has unexpected size % instead of 8", size_of(type_of(UCharIterator._context)));
        assert(((cast(*void)(*instance.length)) - cast(*void)(*instance)) == 8, "UCharIterator.length has unexpected offset % instead of 8", ((cast(*void)(*instance.length)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.length)) == 4, "UCharIterator.length has unexpected size % instead of 4", size_of(type_of(UCharIterator.length)));
        assert(((cast(*void)(*instance.start)) - cast(*void)(*instance)) == 12, "UCharIterator.start has unexpected offset % instead of 12", ((cast(*void)(*instance.start)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.start)) == 4, "UCharIterator.start has unexpected size % instead of 4", size_of(type_of(UCharIterator.start)));
        assert(((cast(*void)(*instance.index)) - cast(*void)(*instance)) == 16, "UCharIterator.index has unexpected offset % instead of 16", ((cast(*void)(*instance.index)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.index)) == 4, "UCharIterator.index has unexpected size % instead of 4", size_of(type_of(UCharIterator.index)));
        assert(((cast(*void)(*instance.limit)) - cast(*void)(*instance)) == 20, "UCharIterator.limit has unexpected offset % instead of 20", ((cast(*void)(*instance.limit)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.limit)) == 4, "UCharIterator.limit has unexpected size % instead of 4", size_of(type_of(UCharIterator.limit)));
        assert(((cast(*void)(*instance.reservedField)) - cast(*void)(*instance)) == 24, "UCharIterator.reservedField has unexpected offset % instead of 24", ((cast(*void)(*instance.reservedField)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.reservedField)) == 4, "UCharIterator.reservedField has unexpected size % instead of 4", size_of(type_of(UCharIterator.reservedField)));
        assert(((cast(*void)(*instance.getIndex)) - cast(*void)(*instance)) == 32, "UCharIterator.getIndex has unexpected offset % instead of 32", ((cast(*void)(*instance.getIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.getIndex)) == 8, "UCharIterator.getIndex has unexpected size % instead of 8", size_of(type_of(UCharIterator.getIndex)));
        assert(((cast(*void)(*instance.move)) - cast(*void)(*instance)) == 40, "UCharIterator.move has unexpected offset % instead of 40", ((cast(*void)(*instance.move)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.move)) == 8, "UCharIterator.move has unexpected size % instead of 8", size_of(type_of(UCharIterator.move)));
        assert(((cast(*void)(*instance.hasNext)) - cast(*void)(*instance)) == 48, "UCharIterator.hasNext has unexpected offset % instead of 48", ((cast(*void)(*instance.hasNext)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.hasNext)) == 8, "UCharIterator.hasNext has unexpected size % instead of 8", size_of(type_of(UCharIterator.hasNext)));
        assert(((cast(*void)(*instance.hasPrevious)) - cast(*void)(*instance)) == 56, "UCharIterator.hasPrevious has unexpected offset % instead of 56", ((cast(*void)(*instance.hasPrevious)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.hasPrevious)) == 8, "UCharIterator.hasPrevious has unexpected size % instead of 8", size_of(type_of(UCharIterator.hasPrevious)));
        assert(((cast(*void)(*instance.current)) - cast(*void)(*instance)) == 64, "UCharIterator.current has unexpected offset % instead of 64", ((cast(*void)(*instance.current)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.current)) == 8, "UCharIterator.current has unexpected size % instead of 8", size_of(type_of(UCharIterator.current)));
        assert(((cast(*void)(*instance.next)) - cast(*void)(*instance)) == 72, "UCharIterator.next has unexpected offset % instead of 72", ((cast(*void)(*instance.next)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.next)) == 8, "UCharIterator.next has unexpected size % instead of 8", size_of(type_of(UCharIterator.next)));
        assert(((cast(*void)(*instance.previous)) - cast(*void)(*instance)) == 80, "UCharIterator.previous has unexpected offset % instead of 80", ((cast(*void)(*instance.previous)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.previous)) == 8, "UCharIterator.previous has unexpected size % instead of 8", size_of(type_of(UCharIterator.previous)));
        assert(((cast(*void)(*instance.reservedFn)) - cast(*void)(*instance)) == 88, "UCharIterator.reservedFn has unexpected offset % instead of 88", ((cast(*void)(*instance.reservedFn)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.reservedFn)) == 8, "UCharIterator.reservedFn has unexpected size % instead of 8", size_of(type_of(UCharIterator.reservedFn)));
        assert(((cast(*void)(*instance.getState)) - cast(*void)(*instance)) == 96, "UCharIterator.getState has unexpected offset % instead of 96", ((cast(*void)(*instance.getState)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.getState)) == 8, "UCharIterator.getState has unexpected size % instead of 8", size_of(type_of(UCharIterator.getState)));
        assert(((cast(*void)(*instance.setState)) - cast(*void)(*instance)) == 104, "UCharIterator.setState has unexpected offset % instead of 104", ((cast(*void)(*instance.setState)) - cast(*void)(*instance)));
        assert(size_of(type_of(UCharIterator.setState)) == 8, "UCharIterator.setState has unexpected size % instead of 8", size_of(type_of(UCharIterator.setState)));
        assert(size_of(UCharIterator) == 112, "UCharIterator has size % instead of 112", size_of(UCharIterator));
    }
}


#if OS == .MACOS {
    libicutu :: #library "macos/libicutu";
    libicuuc :: #library "macos/libicuuc";
    libicui18n :: #library "macos/libicui18n";
    libicudata :: #library "macos/libicudata";
}

